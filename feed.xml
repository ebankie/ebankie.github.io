<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <description>卓尔有信,成就人生!</description>
    <link>http://localhost:4000/blog/</link>
    <atom:link href="http://localhost:4000/blog/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 09 Dec 2016 12:15:35 +0800</pubDate>
    <lastBuildDate>Fri, 09 Dec 2016 12:15:35 +0800</lastBuildDate>
    <generator>Jekyll v3.3.1</generator>
    
      <item>
        <title>flume搭建日志收集系统</title>
        <description>&lt;p&gt;闲话不说直接上配置文件及过程中注意的问题：&lt;/p&gt;

&lt;p&gt;现有两个主机其中一个A做agent1,agent2   B用来collect 日志，并且agent1 agent2统一收集到一个文件里。&lt;/p&gt;

&lt;p&gt;flume 配置相关及使用方法网上太多了，关注及学会以下三个组件的使用方法，就基本搞定&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Source：用来消费传递到该组件的Event ##即收集日志的方式，可以文件，命令……&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Channel：中转Event的一个临时存储，保存有Source组件传递过来的Event&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Sink：从Channel中读取并移除Event，将Event传递到Flow Pipeline中的下一个修复处理服务，或者保存到文件&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一，配置agent&lt;/p&gt;

&lt;p&gt;我官网下载的源码版本为：&lt;/p&gt;

&lt;p&gt;apache-flume-1.7.0-bin.tar.gz&lt;/p&gt;

&lt;p&gt;agent1配置文件flume-agent.conf.properties 如下：&lt;/p&gt;

&lt;p&gt;[well]&lt;/p&gt;

&lt;p&gt;agent1.sources = source1
agent1.sinks = sink1
agent1.channels = channel1&lt;/p&gt;

&lt;h1 id=&quot;describeconfigure-source1&quot;&gt;Describe/configure source1&lt;/h1&gt;

&lt;p&gt;agent1.sources.source1.type = exec
agent1.sources.source1.command = tail -f /data/logs/access-admin.log
agent1.sources.source1.channels = channel1&lt;/p&gt;
&lt;h1 id=&quot;describe-sink1&quot;&gt;Describe sink1&lt;/h1&gt;
&lt;h1 id=&quot;agent1sinkssink1type--file_roll&quot;&gt;agent1.sinks.sink1.type = file_roll&lt;/h1&gt;
&lt;h1 id=&quot;agent1sinkssink1sinkdirectoryhomedevbankiedata&quot;&gt;agent1.sinks.sink1.sink.directory=/home/dev/bankie/data&lt;/h1&gt;
&lt;p&gt;#agent1.sinks.sink1.sink.rollInterval=0
#
agent1.sinks.sink1.channel = channel1
agent1.sinks.sink1.type = avro
agent1.sinks.sink1.hostname = 10.1.0.8 #B服务的IP
agent1.sinks.sink1.port = 44444&lt;/p&gt;

&lt;h1 id=&quot;use-a-channel-which-buffers-events-in-memory&quot;&gt;Use a channel which buffers events in memory&lt;/h1&gt;
&lt;p&gt;agent1.channels.channel1.type = memory
agent1.channels.channel1.capacity = 50000
agent1.channels.channel1.transactionCapacity = 10000&lt;/p&gt;

&lt;p&gt;[/well]&lt;/p&gt;

&lt;p&gt;agent2配置文件flume-agent2.conf 如下：&lt;/p&gt;

&lt;p&gt;[well]&lt;/p&gt;

&lt;p&gt;agent2.sources = source1
agent2.sinks = sink1
agent2.channels = channel1&lt;/p&gt;

&lt;h1 id=&quot;describeconfigure-source1-1&quot;&gt;Describe/configure source1&lt;/h1&gt;

&lt;p&gt;agent2.sources.source1.type = exec
agent2.sources.source1.command = tail -f /data/logs/access-web.log
agent2.sources.source1.channels = channel1&lt;/p&gt;
&lt;h1 id=&quot;describe-sink1-1&quot;&gt;Describe sink1&lt;/h1&gt;
&lt;h1 id=&quot;agent2sinkssink1type--file_roll&quot;&gt;agent2.sinks.sink1.type = file_roll&lt;/h1&gt;
&lt;h1 id=&quot;agent2sinkssink1sinkdirectoryhomedevbankiedata&quot;&gt;agent2.sinks.sink1.sink.directory=/home/dev/bankie/data&lt;/h1&gt;
&lt;p&gt;#agent2.sinks.sink1.sink.rollInterval=0
#
agent2.sinks.sink1.channel = channel1
agent2.sinks.sink1.type = avro
agent2.sinks.sink1.hostname = 10.1.0.8 #B服务IP
agent2.sinks.sink1.port = 44444&lt;/p&gt;

&lt;h1 id=&quot;use-a-channel-which-buffers-events-in-memory-1&quot;&gt;Use a channel which buffers events in memory&lt;/h1&gt;
&lt;p&gt;agent2.channels.channel1.type = memory
agent2.channels.channel1.capacity = 50000
agent2.channels.channel1.transactionCapacity = 10000&lt;/p&gt;

&lt;p&gt;[/well]&lt;/p&gt;

&lt;p&gt;配置文件为conf 或者properties 都可以，关键看起动flume指定的哪个类型&lt;/p&gt;

&lt;p&gt;###特别注意 配置agent2.sinks.sink1.hostname时，网上例子全是agent2.sinks.sink1.bind 1.70后是hostname&lt;/p&gt;

&lt;p&gt;起动命令：&lt;/p&gt;

&lt;p&gt;flume-ng agent -c /home/dev/flume/conf -f /home/dev/flume/conf/flume-agent2.conf -n agent2  -Dflume.root.logger=INFO,console&lt;/p&gt;

&lt;p&gt;flume-ng agent -c /home/dev/flume/conf -f /home/dev/flume/conf/flume-agent1.conf.properties  -n agent1  -Dflume.root.logger=INFO,console&lt;/p&gt;

&lt;p&gt;##flume-ng -n agent1 名字和配置文件一致，否则报错……，第一次配置以为可以自命名，走了弯路！！&lt;/p&gt;

&lt;p&gt;成功信息：&lt;/p&gt;

&lt;p&gt;2016-12-01 14:43:46,847 (lifecycleSupervisor-1-0) [WARN - org.apache.flume.api.NettyAvroRpcClient.configure(NettyAvroRpcClient.java:634)] Using default maxIOWorkers
2016-12-01 14:43:47,133 (lifecycleSupervisor-1-0) [INFO - org.apache.flume.sink.AbstractRpcSink.start(AbstractRpcSink.java:301)] Rpc sink sink1 started.&lt;/p&gt;

&lt;p&gt;二、配置server收集端&lt;/p&gt;

&lt;p&gt;配置文件为：flume-server.conf&lt;/p&gt;

&lt;p&gt;[well]&lt;/p&gt;

&lt;p&gt;a1.sources = r1
a1.sinks = k1
a1.channels = c1&lt;/p&gt;

&lt;p&gt;a1.sources.r1.type = avro  #此处有多种收集方式，网上信息非常多，不再复述
a1.sources.r1.channels = c1
a1.sources.r1.bind = 0.0.0.0
a1.sources.r1.port = 44444&lt;/p&gt;
&lt;h1 id=&quot;use-a-channel-which-buffers-events-in-memory-2&quot;&gt;Use a channel which buffers events in memory&lt;/h1&gt;

&lt;p&gt;a1.channels.c1.type = memory
a1.channels.c1.capacity = 50000
a1.channels.c1.transactionCapacity = 10000&lt;/p&gt;

&lt;p&gt;a1.sinks.k1.type = file_roll  ###此处也有多种发送处理，对接kafka,hdfs 都可以，本文集中收集到文件中
a1.sinks.k1.sink.directory=/home/dev/bankie/data
a1.sinks.k1.sink.rollInterval = 0 ##agent1,agent2合并一个文件里存储
a1.sources.r1.channels = c1
a1.sinks.k1.channel = c1&lt;/p&gt;

&lt;p&gt;[/well]&lt;/p&gt;

&lt;p&gt;起动命令：&lt;/p&gt;

&lt;p&gt;flume-ng agent -c /home/dev/flume/conf -f /home/dev/flume/conf/flume-server.conf -n a1  -Dflume.root.logger=INFO,console&lt;/p&gt;

&lt;p&gt;成功后可以看到有如下信息：&lt;/p&gt;

&lt;p&gt;Avro source r1 started.
2016-12-01 14:49:54,575 (New I/O server boss #9) [INFO - org.apache.avro.ipc.NettyServer$NettyServerAvroHandler.handleUpstream(NettyServer.java:171)] [id: 0x8a07a7bc, /10.1.0.9:543 =&amp;gt; /10.1.0.8:44444] OPEN
2016-12-01 14:49:54,576 (New I/O worker #1) [INFO - org.apache.avro.ipc.NettyServer$NettyServerAvroHandler.handleUpstream(NettyServer.java:171)] [id: 0x8a07a7bc, /10.1.0.9:543 =&amp;gt; /10.1.0.8:44444] BOUND: /10.1.0.8:44444
2016-12-01 14:49:54,576 (New I/O worker #1) [INFO - org.apache.avro.ipc.NettyServer$NettyServerAvroHandler.handleUpstream(NettyServer.java:171)] [id: 0x8a07a7bc, /10.1.0.9:543 =&amp;gt; /10.1.0.8:44444] CONNECTED: /10.1.0.9:54303&lt;/p&gt;

&lt;p&gt;以上有内网映射端口。看自己情况而定&lt;/p&gt;

&lt;p&gt;收集日志信息如下：&lt;/p&gt;

&lt;p&gt;com”&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;[01/Dec/2016:14:51:50 +0800] “GET /admin/index/?a=5 HTTP/1.1 “Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.134 Safari/&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;[01/Dec/2016:14:52:44 +0800] “GET /web/user/ HTTP/1.1 “Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.134 Safari/”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 01 Dec 2016 14:55:27 +0800</pubDate>
        <link>http://localhost:4000/blog/2016/12/01/flume-e6-90-ad-e5-bb-ba-e6-97-a5-e5-bf-97-e6-94-b6-e9-9b-86-e7-b3-bb-e7-bb-9f/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2016/12/01/flume-e6-90-ad-e5-bb-ba-e6-97-a5-e5-bf-97-e6-94-b6-e9-9b-86-e7-b3-bb-e7-bb-9f/</guid>
        
        
        <category>技术文章</category>
        
      </item>
    
      <item>
        <title>nginx缓存使用及原理</title>
        <description>&lt;p&gt;这几天正好为公共账号写几篇技术文章，就整理一下nginx下的缓存，做web注重性能，webcache使用的好，会事半功倍。&lt;/p&gt;

&lt;p&gt;今天重点分析一下web服务器的缓存&lt;/p&gt;

&lt;p&gt;一、nginx分为两类缓存，第一类，控制客户端的本地缓存，第二类就是直接缓存地web服务器的文件缓存。&lt;/p&gt;

&lt;p&gt;1，expires 指令设置静态文件缓存即使用客户端本地缓存。expires可以控制 http 应答中的“Expires ”和“ Cache-Control ”的头标（起到控制页面缓存的作用）,所以在使用浏览器访问的时候，经常可以看到一个状态值304返回.&lt;/p&gt;

&lt;p&gt;最常见的静态文件的缓存,配置方式如下：&lt;/p&gt;

&lt;p&gt;[well]&lt;/p&gt;

&lt;p&gt;location~ .&lt;em&gt;.(gif|jpg|png|htm|html|css|js|flv|ico|swf)(.&lt;/em&gt;) {
expires 6h;
}&lt;/p&gt;

&lt;p&gt;[/well]&lt;/p&gt;

&lt;p&gt;语法： expires [time|epoch|max|off]
默认值： expires off
作用域： http, server, location&lt;/p&gt;

&lt;p&gt;设置expires这个参数即可表示需要客户端缓存时间.如果不想让代理或浏览器缓存，加no-cache参数或private参数：&lt;/p&gt;
&lt;h1 id=&quot;expires-1d&quot;&gt;expires 1d;&lt;/h1&gt;
&lt;p&gt;add_header Cache-Control no-cache;
add_header Cache-Control private;
这样浏览器F5刷新时，返回的依然是200，而不是304.&lt;/p&gt;

&lt;p&gt;分析一下原理,expires使用了特定的时间，在第一次get请求时服务端会在header里返回Last-Modified响应头来确定最后一次修改时间，如果图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img1.gtimg.com/yt/image/16/02/145611248923344.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当客户端第二次访问的时候，request会带有If-Modified-Since响应头来确定缓存时间是否过期，如下图，如果还在缓存时效内，客户端就不会下载缓存内容，服务会返回304，同理时间过了就会重新下载。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img1.gtimg.com/yt/image/16/02/145612083449342.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;总结一下就是客户端使用If-Modified-Since头，和原始服务器中的Last-Modified制作比较，所以实现浏览器缓存并判断是否过期。
简单的说，Last-Modified 与If-Modified-Since 都是用于记录页面最后修改时间的 HTTP 头信息，只是Last-Modified 是由服务器往客户端发送的 HTTP 头，而 If-Modified-Since则是由客户端往服务器发送的头，可以看到，再次请求本地存在的 cache 页面时，客户端会通过 If-Modified-Since头将先前服务器端发过来的 Last-Modified最后修改时间戳发送回去，这是为了让服务器端进行验证，通过这个时间戳判断客户端的页面是否是最新的，如果不是最新的，则返回新的内容，如果是最新的，则返回304告诉客户端其本地cache的页面是最新的，于是客户端就可以直接从本地加载页面了，这样在网络上传输的数据就会大大减少，同时也减轻了服务器的负担。&lt;/p&gt;

&lt;p&gt;2,nginx的proxy模块 可以实现类似于Squid的缓存功能，HTTP的缓存与文件系统或者块设备的缓存还有所不同，文件系统或者块设备的缓存可以使用预取方法做优化，提前预取出将要被访问的部分，但是HTTP的缓存却无法预知文件的访问情形。&lt;/p&gt;

&lt;p&gt;可以在nginx里面实现动态页面的静态化工作。
具体的配置方法如下：
在http域内添加如下参数&lt;/p&gt;

&lt;p&gt;[well]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;proxy_temp_path /var/tmp/nginx/proxy;
proxy_cache_path /var/tmp/nginx/cache levels=1:2 keys_zone=cache_one:20m inactive=1d max_size=5g;

server {

 listen  80;
 server_name localhost;

 root /var/www;

 location ~ \.(jpg|png|jpeg|gif|css|js)$ {
  proxy_cache cache_one;
  proxy_cache_valid 200 304 12h;
  proxy_cache_key $host$uri$is_args$args;
  proxy_set_header Host $host;
  proxy_set_header X-Forwarded-For $remote_addr;
  proxy_pass http://127.0.0.1:8181;
  proxy_set_header X-Forwarded_For $proxy_add_x_forwarded_for;
  expires 1d;
 }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;[/well]&lt;/p&gt;

&lt;p&gt;语法解析：&lt;/p&gt;

&lt;p&gt;说明&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;proxy_temp_path&lt;/code&gt; ： 缓存临时目录。后端的响应并不直接返回客户端，而是先写到一个临时文件中，然后被rename一下当做缓存放在 proxy_cache_path 。0.8.9版本以后允许temp和cache两个目录在不同文件系统上（分区），然而为了减少性能损失还是建议把它们设成一个文件系统上。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;proxy_cache_path ...&lt;/code&gt; ： 设置缓存目录，目录里的文件名是 cache_key 的MD5值。
&lt;code class=&quot;highlighter-rouge&quot;&gt;levels=1:2 keys_zone=cache_one:50m&lt;/code&gt;表示采用2级目录结构，Web缓存区名称为cache_one，内存缓存空间大小为100MB，这个缓冲zone可以被多次使用。文件系统上看到的缓存文件名类似于 /usr/local/nginx-1.6/proxy_cache/c/29/b7f54b2df7773722d382f4809d65029c 。
&lt;code class=&quot;highlighter-rouge&quot;&gt;inactive=2d max_size=2g&lt;/code&gt;表示2天没有被访问的内容自动清除，硬盘最大缓存空间为2GB，超过这个大学将清除最近最少使用的数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;proxy_cache&lt;/code&gt; ： 引用前面定义的缓存区 cache_one&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;proxy_cache_key&lt;/code&gt; ： 定义cache_key&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;proxy_cache_valid&lt;/code&gt; ： 为不同的响应状态码设置不同的缓存时间，比如200、302等正常结果可以缓存的时间长点，而404、500等缓存时间设置短一些，这个时间到了文件就会过期，而不论是否刚被访问过。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上两种方式，修改请求url会导致有缓存失效，是因为nginx以请求url做hash为缓存key，只要更新请求url服务器认为是新的请求。&lt;/p&gt;

&lt;p&gt;文章总结：&lt;/p&gt;

&lt;p&gt;可以看到nginx两种缓存方式，各有所长，根据项目的具体情况联合使用。会对web性能有极大提高.&lt;/p&gt;

</description>
        <pubDate>Mon, 22 Feb 2016 14:06:31 +0800</pubDate>
        <link>http://localhost:4000/blog/2016/02/22/nginx-e7-bc-93-e5-ad-98-e8-ae-be-e8-ae-a1-e5-8f-8a-e5-8e-9f-e7-90-86/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2016/02/22/nginx-e7-bc-93-e5-ad-98-e8-ae-be-e8-ae-a1-e5-8f-8a-e5-8e-9f-e7-90-86/</guid>
        
        
        <category>技术文章</category>
        
      </item>
    
      <item>
        <title>php正则表达式</title>
        <description>&lt;p&gt;经常使用,但是有些基本属性还的查找。今天记录一下，特别是模式匹配及修饰符这部分。网上内容也不多。&lt;/p&gt;

&lt;p&gt;（转自：http://www.cnblogs.com/-run/articles/2371078.html）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;正则表达式定义&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;正则表达式(regular expression)描述了一种字符串匹配的模式，可以用来检查一个串是否含有某种子串、将匹配的子串做替换或者从某个串中取出符合某个条件的子串等。&lt;/p&gt;

&lt;p&gt;列目录时，　dir &lt;em&gt;.txt或ls *.txt中的&lt;/em&gt;.txt就不是一个正则表达式,因为这里&lt;em&gt;与正则式的&lt;/em&gt;的含义是不同的。&lt;/p&gt;

&lt;p&gt;正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为元字符）组成的文字模式。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。&lt;/p&gt;

&lt;p&gt;3.1 普通字符&lt;/p&gt;

&lt;p&gt;由所有那些未显式指定为元字符的打印和非打印字符组成。这包括所有的大写和小写字母字符，所有数字，所有标点符号以及一些符号。&lt;/p&gt;

&lt;p&gt;3.2 非打印字符&lt;/p&gt;

&lt;table cellpadding=&quot;3&quot; cellspacing=&quot;1&quot; align=&quot;center&quot; border=&quot;0&quot; bgcolor=&quot;#eaeaea&quot;&gt;
&lt;tbody&gt;
&lt;tr bgcolor=&quot;#f0f0f0&quot;&gt;
字符
含义
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td width=&quot;40&quot;&gt;\cx
&lt;/td&gt;

&lt;td&gt;匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;\f
&lt;/td&gt;

&lt;td&gt;匹配一个换页符。等价于 \x0c 和 \cL。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;\n
&lt;/td&gt;

&lt;td&gt;匹配一个换行符。等价于 \x0a 和 \cJ。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;\r
&lt;/td&gt;

&lt;td&gt;匹配一个回车符。等价于 \x0d 和 \cM。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;\s
&lt;/td&gt;

&lt;td&gt;匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;\S
&lt;/td&gt;

&lt;td&gt;匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;\t
&lt;/td&gt;

&lt;td&gt;匹配一个制表符。等价于 \x09 和 \cI。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;\v
&lt;/td&gt;

&lt;td&gt;匹配一个垂直制表符。等价于 \x0b 和 \cK。
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;3.3 特殊字符&lt;/p&gt;

&lt;p&gt;所谓特殊字符，就是一些有特殊含义的字符，如上面说的”&lt;em&gt;.txt”中的&lt;/em&gt;，简单的说就是表示任何字符串的意思。如果要查找文件名中有＊的文件，则需要对＊进行转义，即在其前加一个\。ls *.txt。正则表达式有以下特殊字符。&lt;/p&gt;

&lt;table cellpadding=&quot;3&quot; cellspacing=&quot;1&quot; align=&quot;center&quot; border=&quot;0&quot; bgcolor=&quot;#eaeaea&quot;&gt;
&lt;tbody&gt;
&lt;tr bgcolor=&quot;#f0f0f0&quot;&gt;
特别字符
说明
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;$
&lt;/td&gt;

&lt;td&gt;匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 \$。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;( )
&lt;/td&gt;

&lt;td&gt;标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;*
&lt;/td&gt;

&lt;td&gt;匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \*。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;+
&lt;/td&gt;

&lt;td&gt;匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;.
&lt;/td&gt;

&lt;td&gt;匹配除换行符 \n之外的任何单字符。要匹配 .，请使用 \。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;[
&lt;/td&gt;

&lt;td&gt;标记一个中括号表达式的开始。要匹配 [，请使用 \[。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;?
&lt;/td&gt;

&lt;td&gt;匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;\
&lt;/td&gt;

&lt;td&gt;将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\\’ 匹配 “\”，而 ‘\(’ 则匹配 “(”。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;^
&lt;/td&gt;

&lt;td&gt;匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \^。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;{
&lt;/td&gt;

&lt;td&gt;标记限定符表达式的开始。要匹配 {，请使用 \{。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;|
&lt;/td&gt;

&lt;td&gt;指明两项之间的一个选择。要匹配 |，请使用 \|。
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与操作符将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。&lt;/p&gt;

&lt;p&gt;3.4 限定符&lt;/p&gt;

&lt;p&gt;限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有*或+或?或{n}或{n,}或{n,m}共6种。&lt;/p&gt;

&lt;p&gt;*、+和?限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。&lt;/p&gt;

&lt;p&gt;正则表达式的限定符有：&lt;/p&gt;

&lt;table cellpadding=&quot;3&quot; cellspacing=&quot;1&quot; align=&quot;center&quot; border=&quot;0&quot; bgcolor=&quot;#eaeaea&quot;&gt;
&lt;tbody&gt;
&lt;tr bgcolor=&quot;#f0f0f0&quot;&gt;
字符
描述
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;*
&lt;/td&gt;

&lt;td&gt;匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;+
&lt;/td&gt;

&lt;td&gt;匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;?
&lt;/td&gt;

&lt;td&gt;匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 中的”do” 。? 等价于 {0,1}。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;{n}
&lt;/td&gt;

&lt;td&gt;n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;{n,}
&lt;/td&gt;

&lt;td&gt;n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;{n,m}
&lt;/td&gt;

&lt;td&gt;m 和 n 均为非负整数，其中n &amp;lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;3.5 定位符&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用来描述字符串或单词的边界，^和$分别指字符串的开始与结束，\b描述单词的前或后边界，\B表示非单词边界。不能对定位符使用限定符。&lt;/p&gt;

&lt;p&gt;3.6 选择&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;用圆括号将所有选择项括起来，相邻的选择项之间用&lt;/td&gt;
      &lt;td&gt;分隔。但用圆括号会有一个副作用，是相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其中?:是非捕获元之一，还有两个非捕获元是?=和?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。&lt;/p&gt;

&lt;p&gt;3.7 后向引用&lt;/p&gt;

&lt;p&gt;对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左至右所遇到的内容 存储。存储子匹配的缓冲区编号从 1 开始，连续编号直至最大 99 个子表达式。每个缓冲区都可以使用 ‘\n’ 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。&lt;/p&gt;

&lt;p&gt;可以使用非捕获元字符 ‘?:’, ‘?=’, or ‘?!’ 来忽略对相关匹配的保存。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 各种操作符的运算优先级&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;相同优先级的从左到右进行运算，不同优先级的运算先高后低。各种操作符的优先级从高到低如下：&lt;/p&gt;

&lt;table cellpadding=&quot;3&quot; cellspacing=&quot;1&quot; align=&quot;center&quot; border=&quot;0&quot; bgcolor=&quot;#eaeaea&quot;&gt;
&lt;tbody&gt;
&lt;tr bgcolor=&quot;#f0f0f0&quot;&gt;
操作符
描述
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;\
&lt;/td&gt;

&lt;td&gt;转义符
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;(), (?:), (?=), []
&lt;/td&gt;

&lt;td&gt;圆括号和方括号
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;*, +, ?, {n}, {n,}, {n,m}
&lt;/td&gt;

&lt;td&gt;限定符
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;^, $, \anymetacharacter
&lt;/td&gt;

&lt;td&gt;位置和顺序
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;|
&lt;/td&gt;

&lt;td&gt;“或”操作
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;5. 全部符号解释&lt;/strong&gt;&lt;/p&gt;

&lt;table cellpadding=&quot;3&quot; cellspacing=&quot;1&quot; align=&quot;center&quot; border=&quot;0&quot; bgcolor=&quot;#eaeaea&quot;&gt;
&lt;tbody&gt;
&lt;tr bgcolor=&quot;#f0f0f0&quot;&gt;
字符
描述
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;\
&lt;/td&gt;

&lt;td&gt;将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\\’ 匹配 “\” 而 “\(” 则匹配 “(”。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;^
&lt;/td&gt;

&lt;td&gt;匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;$
&lt;/td&gt;

&lt;td&gt;匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;*
&lt;/td&gt;

&lt;td&gt;匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;+
&lt;/td&gt;

&lt;td&gt;匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;?
&lt;/td&gt;

&lt;td&gt;匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 中的”do” 。? 等价于 {0,1}。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;{n}
&lt;/td&gt;

&lt;td&gt;n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;{n,}
&lt;/td&gt;

&lt;td&gt;n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;{n,m}
&lt;/td&gt;

&lt;td&gt;m 和 n 均为非负整数，其中n &amp;lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;?
&lt;/td&gt;

&lt;td&gt;当 该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;.
&lt;/td&gt;

&lt;td&gt;匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;(pattern)
&lt;/td&gt;

&lt;td&gt;匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘\(’ 或 ‘\)’。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;(?:pattern)
&lt;/td&gt;

&lt;td&gt;匹 配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;(?=pattern)
&lt;/td&gt;

&lt;td&gt;正 向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，’Windows (?=95|98|NT|2000)’ 能匹配 “Windows 2000″ 中的 “Windows” ，但不能匹配 “Windows 3.1″ 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;(?!pattern)
&lt;/td&gt;

&lt;td&gt;负 向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如’Windows (?!95|98|NT|2000)’ 能匹配 “Windows 3.1″ 中的 “Windows”，但不能匹配 “Windows 2000″ 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;x|y
&lt;/td&gt;

&lt;td&gt;匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;[xyz]
&lt;/td&gt;

&lt;td&gt;字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;[^xyz]
&lt;/td&gt;

&lt;td&gt;负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p'。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;[a-z]
&lt;/td&gt;

&lt;td&gt;字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;[^a-z]
&lt;/td&gt;

&lt;td&gt;负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;\b
&lt;/td&gt;

&lt;td&gt;匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;\B
&lt;/td&gt;

&lt;td&gt;匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;\cx
&lt;/td&gt;

&lt;td&gt;匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;\d
&lt;/td&gt;

&lt;td&gt;匹配一个数字字符。等价于 [0-9]。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;\D
&lt;/td&gt;

&lt;td&gt;匹配一个非数字字符。等价于 [^0-9]。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;\f
&lt;/td&gt;

&lt;td&gt;匹配一个换页符。等价于 \x0c 和 \cL。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;\n
&lt;/td&gt;

&lt;td&gt;匹配一个换行符。等价于 \x0a 和 \cJ。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;\r
&lt;/td&gt;

&lt;td&gt;匹配一个回车符。等价于 \x0d 和 \cM。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;\s
&lt;/td&gt;

&lt;td&gt;匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;\S
&lt;/td&gt;

&lt;td&gt;匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;\t
&lt;/td&gt;

&lt;td&gt;匹配一个制表符。等价于 \x09 和 \cI。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;\v
&lt;/td&gt;

&lt;td&gt;匹配一个垂直制表符。等价于 \x0b 和 \cK。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;\w
&lt;/td&gt;

&lt;td&gt;匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;\W
&lt;/td&gt;

&lt;td&gt;匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]’。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;\xn
&lt;/td&gt;

&lt;td&gt;匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41′ 匹配 “A”。’\x041′ 则等价于 ‘\x04′ &amp;amp; “1″。正则表达式中可以使用 ASCII 编码。.
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;\num
&lt;/td&gt;

&lt;td&gt;匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1′ 匹配两个连续的相同字符。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;\n
&lt;/td&gt;

&lt;td&gt;标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;\nm
&lt;/td&gt;

&lt;td&gt;标 识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;\nml
&lt;/td&gt;

&lt;td&gt;如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;\un
&lt;/td&gt;

&lt;td&gt;匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;6. 部分例子&lt;/strong&gt;&lt;/p&gt;

&lt;table cellpadding=&quot;3&quot; cellspacing=&quot;1&quot; align=&quot;center&quot; border=&quot;0&quot; bgcolor=&quot;#eaeaea&quot;&gt;
&lt;tbody&gt;
&lt;tr bgcolor=&quot;#f0f0f0&quot;&gt;
正则表达式
说明
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;/\b([a-z]+) \1\b/gi
&lt;/td&gt;

&lt;td&gt;一个单词连续出现的位置
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;/(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/
&lt;/td&gt;

&lt;td&gt;将一个URL解析为协议、域、端口及相对路径
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;/^(?:Chapter|Section) [1-9][0-9]{0,1}$/
&lt;/td&gt;

&lt;td&gt;定位章节的位置
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;/[-a-z]/
&lt;/td&gt;

&lt;td&gt;A至z共26个字母再加一个-号。
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;/ter\b/
&lt;/td&gt;

&lt;td&gt;可匹配chapter，而不能terminal
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;/\Bapt/
&lt;/td&gt;

&lt;td&gt;可匹配chapter，而不能aptitude
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr bgcolor=&quot;#fafafa&quot;&gt;

&lt;td&gt;/Windows(?=95 |98 |NT )/
&lt;/td&gt;

&lt;td&gt;可匹配Windows95或Windows98或WindowsNT,当找到一个匹配后，从Windows后面开始进行下一次
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;7. 正则表达式匹配规则&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;7.1 基本模式匹配&lt;/p&gt;

&lt;p&gt;一切从最基本的开始。模式，是正规表达式最基本的元素，它们是一组描述字符串特征的字符。模式可以很简单，由普通的字符串组成，也可以非常复杂，往往用特殊的字符表示一个范围内的字符、重复出现，或表示上下文。例如：&lt;/p&gt;

&lt;p&gt;^once&lt;/p&gt;

&lt;p&gt;这个模式包含一个特殊的字符^，表示该模式只匹配那些以once开头的字符串。例如该模式与字符串”once upon a time”匹配，与”There once was a man from NewYork”不匹配。正如如^符号表示开头一样，$符号用来匹配那些以给定模式结尾的字符串。&lt;/p&gt;

&lt;p&gt;bucket$&lt;/p&gt;

&lt;p&gt;这个模式与”Who kept all of this cash in a bucket”匹配，与”buckets”不匹配。字符^和$同时使用时，表示精确匹配（字符串与模式一样）。例如：&lt;/p&gt;

&lt;p&gt;^bucket$&lt;/p&gt;

&lt;p&gt;只匹配字符串”bucket”。如果一个模式不包括^和$，那么它与任何包含该模式的字符串匹配。例如：模式&lt;/p&gt;

&lt;p&gt;once&lt;/p&gt;

&lt;p&gt;与字符串&lt;/p&gt;

&lt;p&gt;There once was a man from NewYork
Who kept all of his cash in a bucket.&lt;/p&gt;

&lt;p&gt;是匹配的。&lt;/p&gt;

&lt;p&gt;在该模式中的字母(o-n-c-e)是字面的字符，也就是说，他们表示该字母本身，数字也是一样的。其他一些稍微复杂的字符，如标点符号和白字符（空格、 制表符等），要用到转义序列。所有的转义序列都用反斜杠()打头。制表符的转义序列是：\t。所以如果我们要检测一个字符串是否以制表符开头，可以用这 个模式：&lt;/p&gt;

&lt;p&gt;^\t&lt;/p&gt;

&lt;p&gt;类似的，用\n表示“新行”，\r表示回车。其他的特殊符号，可以用在前面加上反斜杠，如反斜杠本身用\表示，句号.用.表示，以此类推。&lt;/p&gt;

&lt;p&gt;7.2 字符簇&lt;/p&gt;

&lt;p&gt;在INTERNET的程序中，正规表达式通常用来验证用户的输入。当用户提交一个FORM以后，要判断输入的电话号码、地址、EMAIL地址、信用卡号码等是否有效，用普通的基于字面的字符是不够的。&lt;/p&gt;

&lt;p&gt;所以要用一种更自由的描述我们要的模式的办法，它就是字符簇。要建立一个表示所有元音字符的字符簇，就把所有的元音字符放在一个方括号里：&lt;/p&gt;

&lt;p&gt;[AaEeIiOoUu]&lt;/p&gt;

&lt;p&gt;这个模式与任何元音字符匹配，但只能表示一个字符。用连字号可以表示一个字符的范围，如：&lt;/p&gt;

&lt;p&gt;[a-z] //匹配所有的小写字母
[A-Z] //匹配所有的大写字母
[a-zA-Z] //匹配所有的字母
[0-9] //匹配所有的数字
[0-9.-] //匹配所有的数字，句号和减号
[ \f\r\t\n] //匹配所有的白字符&lt;/p&gt;

&lt;p&gt;同样的，这些也只表示一个字符，这是一个非常重要的。如果要匹配一个由一个小写字母和一位数字组成的字符串，比如”z2″、”t6″或”g7″，但不是”ab2″、”r2d3″ 或”b52″的话，用这个模式：&lt;/p&gt;

&lt;p&gt;^[a-z][0-9]$&lt;/p&gt;

&lt;p&gt;尽管[a-z]代表26个字母的范围，但在这里它只能与第一个字符是小写字母的字符串匹配。&lt;/p&gt;

&lt;p&gt;前面曾经提到^表示字符串的开头，但它还有另外一个含义。当在一组方括号里使用^是，它表示“非”或“排除”的意思，常常用来剔除某个字符。还用前面的例子，我们要求第一个字符不能是数字：&lt;/p&gt;

&lt;p&gt;^[^0-9][0-9]$&lt;/p&gt;

&lt;p&gt;这个模式与”&amp;amp;5″、”g7″及”-2″是匹配的，但与”12″、”66″是不匹配的。下面是几个排除特定字符的例子：&lt;/p&gt;

&lt;p&gt;[^a-z] //除了小写字母以外的所有字符
[^\\/\^] //除了()(/)(^)之外的所有字符
[^\”\’] //除了双引号(”)和单引号(’)之外的所有字符&lt;/p&gt;

&lt;p&gt;特殊字符”.” (点，句号)在正规表达式中用来表示除了“新行”之外的所有字符。所以模式”^.5$”与任何两个字符的、以数字5结尾和以其他非“新行”字符开头的字符串匹配。模式”.”可以匹配任何字符串，除了空串和只包括一个“新行”的字符串。&lt;/p&gt;

&lt;p&gt;PHP的正规表达式有一些内置的通用字符簇，列表如下：&lt;/p&gt;

&lt;p&gt;字符簇含义&lt;/p&gt;

&lt;p&gt;[[:alpha:]] 任何字母
[[:digit:]] 任何数字
[[:alnum:]] 任何字母和数字
[[:space:]] 任何白字符
[[:upper:]] 任何大写字母
[[:lower:]] 任何小写字母
[[:punct:]] 任何标点符号
[[:xdigit:]] 任何16进制的数字，相当于[0-9a-fA-F]&lt;/p&gt;

&lt;p&gt;7.3 确定重复出现&lt;/p&gt;

&lt;p&gt;到现在为止，你已经知道如何去匹配一个字母或数字，但更多的情况下，可能要匹配一个单词或一组数字。一个单词有若干个字母组成，一组数字有若干个单数组成。跟在字符或字符簇后面的花括号({})用来确定前面的内容的重复出现的次数。&lt;/p&gt;

&lt;p&gt;字符簇 含义
^[a-zA-Z_]$ 所有的字母和下划线
^[[:alpha:]]{3}$ 所有的3个字母的单词
^a$ 字母a
^a{4}$ aaaa
^a{2,4}$ aa,aaa或aaaa
^a{1,3}$ a,aa或aaa
^a{2,}$ 包含多于两个a的字符串
^a{2,} 如：aardvark和aaab，但apple不行
a{2,} 如：baad和aaa，但Nantucket不行
\t{2} 两个制表符
.{2} 所有的两个字符&lt;/p&gt;

&lt;p&gt;这些例子描述了花括号的三种不同的用法。一个数字，{x}的意思是“前面的字符或字符簇只出现x次”；一个数字加逗号，{x,}的意思是“前面的内容出现 x或更多的次数”；两个用逗号分隔的数字，{x,y}表示“前面的内容至少出现x次，但不超过y次”。我们可以把模式扩展到更多的单词或数字：&lt;/p&gt;

&lt;p&gt;^[a-zA-Z0-9_]{1,}$ //所有包含一个以上的字母、数字或下划线的字符串
^[0-9]{1,}$ //所有的正数
^-{0,1}[0-9]{1,}$ //所有的整数
^-{0,1}[0-9]{0,}.{0,1}[0-9]{0,}$ //所有的小数&lt;/p&gt;

&lt;p&gt;最后一个例子不太好理解，是吗？这么看吧：与所有以一个可选的负号(-{0,1})开头(^)、跟着0个或更多的数字([0-9]{0,})、和一个可 选的小数点(.{0,1})再跟上0个或多个数字([0-9]{0,})，并且没有其他任何东西($)。下面你将知道能够使用的更为简单的方法。&lt;/p&gt;

&lt;p&gt;特殊字符”?”与{0,1}是相等的，它们都代表着：“0个或1个前面的内容”或“前面的内容是可选的”。所以刚才的例子可以简化为：&lt;/p&gt;

&lt;p&gt;^-?[0-9]{0,}.?[0-9]{0,}$&lt;/p&gt;

&lt;p&gt;特殊字符”*”与{0,}是相等的，它们都代表着“0个或多个前面的内容”。最后，字符”+”与 {1,}是相等的，表示“1个或多个前面的内容”，所以上面的4个例子可以写成：&lt;/p&gt;

&lt;p&gt;^[a-zA-Z0-9_]+$ //所有包含一个以上的字母、数字或下划线的字符串
^[0-9]+$ //所有的正数
^-?[0-9]+$ //所有的整数
^-?[0-9]&lt;em&gt;.?[0-9]&lt;/em&gt;$ //所有的小数&lt;/p&gt;

&lt;p&gt;当然这并不能从技术上降低正规表达式的复杂性，但可以使它们更容易阅读。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;通用模式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;定界符，通常使用 “/”做为定界符开始和结束,也可以使用”#”。&lt;/p&gt;

&lt;p&gt;什么时候使用”#”呢?一般是在你的字符串中有很多”/”字符的时候，因为正则的时候这种字符需要转义&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PHP正则表达式 修饰符 /i, /is, /s, /isU,/x&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;PHP正则表达式修饰符的种类及介绍：&lt;/p&gt;

&lt;p&gt;◆i ：如果在修饰符中加上”i”，则正则将会取消大小写敏感性，即”a”和”A” 是一样的。&lt;/p&gt;

&lt;p&gt;◆m：默认的正则开始”^”和结束”$”只是对于正则字符串如果在修饰符中加上”m”，那么开始和结束将会指字符串的每一行：每一行的开头就是”^”，结尾就是”$”。&lt;/p&gt;

&lt;p&gt;◆s：如果在修饰符中加入”s”，那么默认的”.”代表除了换行符以外的任何字符将会变成任意字符，也就是包括换行符！&lt;/p&gt;

&lt;p&gt;◆x：如果加上该修饰符，表达式中的空白字符将会被忽略，除非它已经被转义。&lt;/p&gt;

&lt;p&gt;◆e：本修饰符仅仅对于replacement有用，代表在replacement中作为PHP代码。&lt;/p&gt;

&lt;p&gt;◆A：如果使用这个修饰符，那么表达式必须是匹配的字符串中的开头部分。比如说”/a/A”匹配”abcd”。&lt;/p&gt;

&lt;p&gt;◆E：与”m”相反，如果使用这个修饰符，那么”$”将匹配绝对字符串的结尾，而不是换行符前面，默认就打开了这个模式。&lt;/p&gt;

&lt;p&gt;◆U：和问号的作用差不多，用于设置”贪婪模式”。&lt;/p&gt;

&lt;h4 id=&quot;收集写过的正则表达式&quot;&gt;&lt;strong&gt;收集写过的正则表达式&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;取img src 及替换_
_&lt;/p&gt;

&lt;p&gt;preg_match(‘/&amp;lt;img\s+[^&amp;gt;]&lt;em&gt;?src=('|&quot;)(.&lt;/em&gt;?)\1[^&amp;gt;]&lt;em&gt;?&amp;gt;/’, $con[‘conn’], $matches);
$con[‘conn’] = preg_replace(‘/(&amp;lt;img.+src=&quot;)(.&lt;/em&gt;?)(&quot;(jpg|gif|bmp|bnp|png)&quot;?.+&amp;gt;)/i’,”${1}”.$img.”${3}”,$con[‘co
nn’]);&lt;/p&gt;

</description>
        <pubDate>Wed, 13 Jan 2016 10:59:51 +0800</pubDate>
        <link>http://localhost:4000/blog/2016/01/13/php-e6-ad-a3-e5-88-99-e8-a1-a8-e8-be-be-e5-bc-8f/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2016/01/13/php-e6-ad-a3-e5-88-99-e8-a1-a8-e8-be-be-e5-bc-8f/</guid>
        
        
        <category>技术文章</category>
        
      </item>
    
      <item>
        <title>Golang channels 教程</title>
        <description>&lt;p&gt;转自：http://www.oschina.net/translate/golang-channels-tutorial&lt;/p&gt;

&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;




Go语言内置了书写并发程序的工具。将go声明放到一个需调用的函数之前，在相同地址空间调用运行这个函数，这样该函数执行时便会作为一个独立的并发线程。这种线程在Go语言中称作goroutine。在这里我要提一下，并发并不总是意味着并行。Goroutines是指在硬件允许情况下创建能够并行执行程序的架构。这是这个主题的一次讨论：[并发不是并行](http://blog.golang.org/concurrency-is-not-parallelism)。

让我们从一个例子开始：








[?](http://www.oschina.net/translate/golang-channels-tutorial#)


&lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;


1




2




3




4




5

&lt;/td&gt;

&lt;td&gt;





`func main() {`




`     ``// Start a goroutine and execute println concurrently`




`     ``go println(``&quot;goroutine message&quot;``)`




`     ``println(``&quot;main function message&quot;``)`




`}`




&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;








&lt;/td&gt;

&lt;td valign=&quot;top&quot;&gt;





###### [ ](http://my.oschina.net/Garfielt)





 
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;




这段程序将输出main function messageand **或者**goroutine message。我说“ **或者**”是因为催生的goroutine有一些特点。当你运行一个goroutine时，调用的代码（在我们的例子里它是main函数）不等待goroutine完成，而是继续往下运行。在调用完println后main函数结束了它的执行，在Go语言里这意味着这个程序及所有催生的goroutines停止执行。但是，在这个发生之前，goroutine可能已经完成了其代码的执行并输出了goroutine message字符。

你明白这些后必须有方法来避免这种情况。这就是Go语言中**channels**的作用。



&lt;/td&gt;

&lt;td valign=&quot;top&quot;&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td rowspan=&quot;2&quot;&gt;





### Channels 基础知识


Channels用来同步并发执行的函数并提供它们某种传值交流的机制。Channels的一些特性：通过channel传递的元素类型、容器（或缓冲区）和传递的方向由“&amp;lt;-”操作符指定。你可以使用内置函数 [make](http://golang.org/ref/spec#Making_slices_maps_and_channels)分配一个channel:








[?](http://www.oschina.net/translate/golang-channels-tutorial#)


&lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;


1




2




3




4




5

&lt;/td&gt;

&lt;td&gt;





`i := make(chan ``int``)       ``// by default the capacity is 0`




`s := make(chan string, 3) ``// non-zero capacity`







`r := make(&amp;lt;-chan ``bool``)          ``// can only read from`




`w := make(chan&amp;lt;- []os.FileInfo) ``// can only write to`




&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;






Channels是一个第一类值（一个对象在运行期间被创建，可以当做一个参数被传递，从子函数返回或者可以被赋给一个变量。）可以像其他值那样在任何地方使用：作为一个结构元素，函数参数、函数返回值甚至另一个channel的类型：








[?](http://www.oschina.net/translate/golang-channels-tutorial#)


&lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;


1




2




3




4




5




6




7




8




9




10




11




12




13

&lt;/td&gt;

&lt;td&gt;





`// a channel which:`




`//  - you can only write to`




`//  - holds another channel as its value`




`c := make(chan&amp;lt;- chan ``bool``)`







`// function accepts a channel as a parameter`




`func readFromChannel(input &amp;lt;-chan string) {}`







`// function returns a channel`




`func getChannel() chan ``bool` `{`




`     ``b := make(chan ``bool``)`




`     ``return` `b`




`}`




&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;








&lt;/td&gt;

&lt;td valign=&quot;top&quot;&gt; 
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;

&lt;td valign=&quot;bottom&quot;&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td rowspan=&quot;2&quot;&gt;


在读、写channel的时候要格外注意  [&amp;lt;-](http://golang.org/ref/spec#Receive_operator) 操作符。它的位置关乎到channel变量的读写操作。下面的例子标明了它的使用方法，但我还是要提醒你，这段代码 **并不会被完整地执行**，原因我们后面再讲：








[?](http://www.oschina.net/translate/golang-channels-tutorial#)


&lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;


1




2




3




4




5




6

&lt;/td&gt;

&lt;td&gt;





`func main() {`




`     ``c := make(chan ``int``)`




`     ``c &amp;lt;- 42    ``// 写入channel`




`     ``val := &amp;lt;-c ``// 从channel中读取`




`     ``println(val)`




`}`




&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;






现在我们知道了什么是channel，如何创建channel并且学了一些基础操作。现在让我们回到第一个示例，看看channel到底是如何帮助我们的。








[?](http://www.oschina.net/translate/golang-channels-tutorial#)


&lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;


1




2




3




4




5




6




7




8




9




10




11




12




13




14




15




16




17

&lt;/td&gt;

&lt;td&gt;





`func main() {`




`     ``// 创建一个channel用以同步goroutine`




`     ``done := make(chan ``bool``)`







`     ``// 在goroutine中执行输出操作`




`     ``go func() {`




`          ``println(``&quot;goroutine message&quot;``)`







`          ``// 告诉main函数执行完毕.`




`          ``// 这个channel在goroutine中是可见的`




`          ``// 因为它是在相同的地址空间执行的.`




`          ``done &amp;lt;- ``true`




`     ``}()`







`     ``println(``&quot;main function message&quot;``)`




`     ``&amp;lt;-done ``// 等待goroutine结束`




`}`




&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;






这个程序将顺溜地打印2条信息。为什么呢？因为channel没有缓冲（我们没有指定其容量）。所有基于未缓冲的channel的的操作会将操作锁死直到输出和接收全部准备就绪。这就是为什么未缓冲channel也被称作同步（synchronous）。在我们的例子中，主函数中的操作符&amp;lt;-将会把程序锁死直到goroutine在channel中写入数据。因此程序只有在读取操作成功结束后才会终止。



&lt;/td&gt;

&lt;td valign=&quot;top&quot;&gt;


&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;

&lt;td valign=&quot;bottom&quot;&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;




为了避免存在一个channel的缓冲区所有读取操作都在没有锁定的情况下顺利完成（如果缓冲区是空的）并且写入操作也顺利结束（缓冲区不满），这样的channel被称作非同步的channel。下面是一个用来描述这两者区别的例子：








[?](http://www.oschina.net/translate/golang-channels-tutorial#)


&lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;


1




2




3




4




5




6




7




8




9




10




11




12




13




14




15




16




17

&lt;/td&gt;

&lt;td&gt;





`func main() {`




`     ``message := make(chan string) ``// 无缓冲`




`     ``count := 3`







`     ``go func() {`




`          ``for` `i := 1; i &amp;lt;= count; i++ {`




`               ``fmt.Println(``&quot;send message&quot;``)`




`               ``message &amp;lt;- fmt.Sprintf(``&quot;message %d&quot;``, i)`




`          ``}`




`     ``}()`







`     ``time``.Sleep(``time``.Second * 3)`







`     ``for` `i := 1; i &amp;lt;= count; i++ {`




`          ``fmt.Println(&amp;lt;-message)`




`     ``}`




`}`




&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;






在这个例子中，输出信息是一个同步的channel，程序输出结果为：








[?](http://www.oschina.net/translate/golang-channels-tutorial#)


&lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;


1




2




3




4




5




6




7

&lt;/td&gt;

&lt;td&gt;





`send message`




`// 等待3秒`




`message 1`




`send message`




`send message`




`message 2`




`message 3`




&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;






正如你所看到的，在第一次goroutine中写入channel之后，其它在同一个channel中的写入操作都被锁住了，直到第一次读取操作执行完毕（大约3秒）。

现在我们提供一个缓冲区给输出信息的channel，例如：定义初始化行将被改为：message := make(chan string, 2)。这次程序输出将变为：








[?](http://www.oschina.net/translate/golang-channels-tutorial#)


&lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;


1




2




3




4




5




6




7

&lt;/td&gt;

&lt;td&gt;





`send message`




`send message`




`send message`




`// 等待3秒`




`message 1`




`message 2`




`message 3`




&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;






这里我们看到所有的写操作的执行都不会等待第一次对缓冲区的读取操作结束，channel允许储存所有的三条信息。通过修改channel容器，我们通过可以控制处理信息的总数达到限制系统输出的目的。



&lt;/td&gt;

&lt;td valign=&quot;top&quot;&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;





### 死锁


现在让我们回到前面那个没有成功运行的读/写操作示例：








[?](http://www.oschina.net/translate/golang-channels-tutorial#)


&lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;


1




2




3




4




5




6

&lt;/td&gt;

&lt;td&gt;





`func main() {`




`     ``c := make(chan ``int``)`




`     ``c &amp;lt;- 42    ``// 写入channel`




`     ``val := &amp;lt;-c ``// 读取channel`




`     ``println(val)`




`}`




&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;






一旦运行此程序，你将得到以下错误：








[?](http://www.oschina.net/translate/golang-channels-tutorial#)


&lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;


1




2




3




4




5




6

&lt;/td&gt;

&lt;td&gt;





`fatal error: all goroutines are asleep - deadlock!`







`goroutine 1 [chan send]:`




`main.main()`




`     ``/fullpathtofile/channelsio.go:5 +0x54`




`exit` `status 2`




&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;






这个错误就是我们所知的**死锁**. 在这种情况下，两个goroutine互相等待对方释放资源，造成双方都无法继续运行。GO语言可以在运行时检测这种死锁并报错。这个错误是因为锁的自身特性产生的。

代码在次以单线程的方式运行，逐行运行。向channel写入的操作（c &amp;lt;- 42）会锁住整个程序的执行进程，因为在同步channel中的写操作只有在读取器准备就绪后才能成功执行。然而在这里，我们在写操作的下一行才创建了读取器。

为了使程序顺利执行，我们需要做如下改动：








[?](http://www.oschina.net/translate/golang-channels-tutorial#)


&lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;


1




2




3




4




5




6




7




8




9




10

&lt;/td&gt;

&lt;td&gt;





`func main() {`




`     ``c := make(chan ``int``)`




`     `




`     ``// 使写操作在另一个goroutine中执行。`




`     ``go func() {`




`        ``c &amp;lt;- 42`




`     ``}()`




`     ``val := &amp;lt;-c`




`     ``println(val)`




`}`




&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;








&lt;/td&gt;

&lt;td valign=&quot;top&quot;&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;








### 范围化的channels 和channel的关闭


在前面的一个例子中，我们向channel发送了多条信息并读取它们，读取器部分的代码如下：








[?](http://www.oschina.net/translate/golang-channels-tutorial#)


&lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;


1




2




3

&lt;/td&gt;

&lt;td&gt;





`for` `i := 1; i &amp;lt;= count; i++ {`




`     ``fmt.Println(&amp;lt;-message)`




`}`




&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;






为了在执行读取操作的同时避免产生死锁，我们需要知道发送消息的确切数目，因为我们不能读取比写入条数还多的数据。但是这样很不方便，下面我们就提供了一个更为人性化的方法。

在Go语言中，存在一种称为范围表达式的代码，它允许程序反复声明数组、字符串、切片、图和channel，重复声明会一直持续到channel的关闭。请看下面的例子（虽然现在还不能执行）：








[?](http://www.oschina.net/translate/golang-channels-tutorial#)


&lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;


1




2




3




4




5




6




7




8




9




10




11




12




13




14

&lt;/td&gt;

&lt;td&gt;





`func main() {`




`     ``message := make(chan string)`




`     ``count := 3`







`     ``go func() {`




`          ``for` `i := 1; i &amp;lt;= count; i++ {`




`               ``message &amp;lt;- fmt.Sprintf(``&quot;message %d&quot;``, i)`




`          ``}`




`     ``}()`







`     ``for` `msg := range message {`




`          ``fmt.Println(msg)`




`     ``}`




`}`




&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;








&lt;/td&gt;

&lt;td valign=&quot;top&quot;&gt;


###### 



&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;


很不幸的是，这段代码现在还不能运行。正如我们之前提到的，范围（range）只有等到channel关闭后才会运行。因此我们需要使用  [close](http://golang.org/ref/spec#Close) 函数关闭channel，程序就会变成下面这个样子：








[?](http://www.oschina.net/translate/golang-channels-tutorial#)


&lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;


1




2




3




4




5




6

&lt;/td&gt;

&lt;td&gt;





`go func() {`




`     ``for` `i := 1; i &amp;lt;= count; i++ {`




`          ``message &amp;lt;- fmt.Sprintf(``&quot;message %d&quot;``, i)`




`     ``}`




`     ``close(message)`




`}()`




&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;






关闭channel还有另外一个好处——被关闭的channel内的读取操作将不会引发锁，而是始终长生默认的对应channel类型的值：








[?](http://www.oschina.net/translate/golang-channels-tutorial#)


&lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;


1




2




3




4




5




6




7

&lt;/td&gt;

&lt;td&gt;





`done := make(chan ``bool``)`




`close(done)`







`//不会产生锁，打印两次false`




`//因为false是bool类型的默认值`




`println(&amp;lt;-done)`




`println(&amp;lt;-done)`




&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;






这个特性可以被用于控制goroutine的同步，让我们再回顾一下之前同步的例子：








[?](http://www.oschina.net/translate/golang-channels-tutorial#)


&lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;


1




2




3




4




5




6




7




8




9




10




11




12




13

&lt;/td&gt;

&lt;td&gt;





`func main() {`




`     ``done := make(chan ``bool``)`







`     ``go func() {`




`          ``println(``&quot;goroutine message&quot;``)`







`          ``// 我们只关心被是否存在传送这个事实，而不是值的内容。`




`          ``done &amp;lt;- ``true`




`     ``}()`







`     ``println(``&quot;main function message&quot;``)`




`     ``&amp;lt;-done`




`}`




&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;






在这里，done channel仅仅被用于同步程序执行，而不是发送数据。再举一个类似的例子：








[?](http://www.oschina.net/translate/golang-channels-tutorial#)


&lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;


1




2




3




4




5




6




7




8




9




10




11




12




13




14

&lt;/td&gt;

&lt;td&gt;





`func main() {`




`     ``// 与数据内容无关`




`     ``done := make(chan ``struct``{})`







`     ``go func() {`




`          ``println(``&quot;goroutine message&quot;``)`







`          ``// 发送信号&quot;I'm done&quot;`




`          ``close(done)`




`     ``}()`







`     ``println(``&quot;main function message&quot;``)`




`     ``&amp;lt;-done`




`}`




&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;






我们关闭了goroutine中的channel，读取操作不会产生锁，因此主函数可以继续执行下去。



&lt;/td&gt;

&lt;td valign=&quot;top&quot;&gt;


######  



&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;





### 多channel模式和channel的选择


在真正的项目开发中，你可能需要多个goroutine和channel。当各部分的独立性越强，他们之间也就越需要高效的同步措施。让我们看个略微复杂的例子：








[?](http://www.oschina.net/translate/golang-channels-tutorial#)


&lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;


1




2




3




4




5




6




7




8




9




10




11




12




13




14




15




16




17




18




19




20




21




22




23

&lt;/td&gt;

&lt;td&gt;





`func getMessagesChannel(msg string, delay ``time``.Duration) &amp;lt;-chan string {`




`     ``c := make(chan string)`




`     ``go func() {`




`          ``for` `i := 1; i &amp;lt;= 3; i++ {`




`               ``c &amp;lt;- fmt.Sprintf(``&quot;%s %d&quot;``, msg, i)`




`               ``// 在发送信息前等待`




`               ``time``.Sleep(``time``.Millisecond * delay)`




`          ``}`




`     ``}()`




`     ``return` `c`




`}`







`func main() {`




`     ``c1 := getMessagesChannel(``&quot;first&quot;``, 300)`




`     ``c2 := getMessagesChannel(``&quot;second&quot;``, 150)`




`     ``c3 := getMessagesChannel(``&quot;third&quot;``, 10)`







`     ``for` `i := 1; i &amp;lt;= 3; i++ {`




`          ``println(&amp;lt;-c1)`




`          ``println(&amp;lt;-c2)`




`          ``println(&amp;lt;-c3)`




`     ``}`




`}`




&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;






这里我们创建了一个方法，用来创建channel并定义了一个goroutine使之在一此调用中向channel发送三条信息。我们看到，c3理应是最后一次channel调用，所以它的输出信息应该在其它信息之前。但是我们得到的却是如下输出：








[?](http://www.oschina.net/translate/golang-channels-tutorial#)


&lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;


1




2




3




4




5




6




7




8




9

&lt;/td&gt;

&lt;td&gt;





`first 1`




`second 1`




`third 1`




`first 2`




`second 2`




`third 2`




`first 3`




`second 3`




`third 3`




&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;








&lt;/td&gt;

&lt;td valign=&quot;top&quot;&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;




显然我们成功输出了所有的信息，这是因为第一个channel中的读取操作在每个循环声明中被锁住300毫秒，其它操作必须随之进入等待状态。而我们期望的却是从所有channel中尽快读取信息。

我们可以使用[select](http://golang.org/ref/spec#Select_statements) 在多个channel之间进行选择。这种选择类似于普通的switch，但是所有的情况在这里都是数值传递操作（读/写）。即使操作数增加，程序也不会在更多的锁下运行。因此，如果想要达到我们之前的目的，我们可以这么改写程序：








[?](http://www.oschina.net/translate/golang-channels-tutorial#)


&lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;


1




2




3




4




5




6




7




8




9




10

&lt;/td&gt;

&lt;td&gt;





`for` `i := 1; i &amp;lt;= 9; i++ {`




`     ``select {`




`     ``case` `msg := &amp;lt;-c1:`




`          ``println(msg)`




`     ``case` `msg := &amp;lt;-c2:`




`          ``println(msg)`




`     ``case` `msg := &amp;lt;-c3:`




`          ``println(msg)`




`     ``}`




`}`




&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;








&lt;/td&gt;

&lt;td valign=&quot;top&quot;&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;注意循环中的9这个数：每个channel存在三个写操作，这就是为什么这里需要9次循环的原因。在一般的守护进程中，我们可以使用无限循环执行选择操作，但如果我在这里那么做了，那我们将得到一个死锁：








[?](http://www.oschina.net/translate/golang-channels-tutorial#)


&lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;


1




2




3




4




5




6




7




8




9

&lt;/td&gt;

&lt;td&gt;





`first 1`




`second 1`




`third 1 ``// 这个channel将不会等待其他channel`




`third 2`




`third 3`




`second 2`




`first 2`




`second 3`




`first 3`




&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;








### 总结.


channel是Go语言中颇为有趣的一个机制。但是在高效地使用它们之前你必须搞清楚他们是如何工作的。我试图在本文中对channel做出最基础的解释，如果你想要更深入地学习这个机制，我建议你阅读以下文章：



	
  * [并发不是并行](http://blog.golang.org/concurrency-is-not-parallelism) - Rob Pike 之前我们有提到过

	
  * [Go语言并发模式——初级篇](http://www.youtube.com/watch?v=f6kdp27TYZs)

	
  * [Go语言并发模式——高级篇](http://www.youtube.com/watch?v=QDDwwePbDtw)




后台运行命令： nohup go run web.go &amp;amp;

命令：fg  %1  显示到前台
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

</description>
        <pubDate>Fri, 27 Nov 2015 14:26:13 +0800</pubDate>
        <link>http://localhost:4000/blog/2015/11/27/golang-channels-e6-95-99-e7-a8-8b/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2015/11/27/golang-channels-e6-95-99-e7-a8-8b/</guid>
        
        
        <category>技术文章</category>
        
      </item>
    
      <item>
        <title>翻墙路由器的原理与实现</title>
        <description>&lt;p&gt;转自：http://drops.wooyun.org/papers/10177?123&amp;amp;from=timeline&amp;amp;isappinstalled=0&lt;/p&gt;

&lt;p&gt;编辑备注:因无法联系到原作者以及文章原文声明放弃著作权以及领接权，因此进行转载，希望作者能够联系邮箱 drops@wooyun.org&lt;/p&gt;

&lt;h1 id=&quot;0x00-开篇&quot;&gt;0x00 开篇&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;GFW具有重大的社会意义。无论是正面的社会意义，还是负面的意义。无论你是讨厌，还是憎恨。它都在那里。在可以预见的将来，墙还会继续存在。我们要学会如何与其共存。我是一个死搞技术的，就是打算搞技术到死的那种人。当我读到“西厢计划”的博客上的这么一段话时，我被深深的触动了。不是为了什么政治目的，不是为了什么远大理想，仅仅做为一个死搞技术的人显摆自己的价值，我也必须做些什么。博客上的原话是这么写的：&lt;/p&gt;

&lt;blockquote&gt;作为个搞技术的人，我们要干点疯狂的事。如果我们不动手，我们就要被比我们差的远的坏技术人员欺负。这太丢人了。眼前就是，GFW这个东西，之前是我们不抱团，让它猖狂了。现在咱们得凑一起，想出来一个办法让它郁闷一下，不能老被欺负吧。要不，等到未来，后代会嘲笑我们这些没用的家伙，就象我们说别人“你怎么不反抗？”&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://static.wooyun.org//drops/20151117/2015111702570978132.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;gfwrev.blogspot.com&lt;/p&gt;

&lt;p&gt;我把翻墙看成一场我们与GFW之间的博弈，是一个不断对抗升级的动态过程。目前整体的博弈态势来讲是GFW占了绝对的上风。我们花费了大量的金钱（买VPS买VPN），花费大量时间（学习各种翻墙技术），而GFW只需要简单发几个包，配几个路由规则就可以让你的心血都白费。&lt;/p&gt;

&lt;p&gt;GFW并不需要检查所有的上下行流量中是不是有不和谐的内容，很多时候只需要检查连接的前几个包就可以判断出是否要阻断这个连接。为了规避这种检查，我们就需要把所有的流量都通过第三方代理，还要忍受不稳定，速度慢等各种各样的问题。花费的是大量的研究的时间，切换线路的时间，找出是什么导致不能用的时间，当然还有服务器的租用费用和带宽费用。我的感觉是，这就像太极里的四两拨千斤。GFW只需要付出很小的成本，就迫使了我们去付出很大的反封锁成本，而且这种成本好像是越来越高了。&lt;/p&gt;

&lt;p&gt;这场博弈的不公平之处在于，GFW拥有国家的资源和专业的团队。而我们做为个体，愿意花费在翻墙上的时间与金钱是非常有限的。在竞争激烈的北上广深，每天辛苦忙碌的白领们。翻墙无非是为了方便自己的工作而已。不可能在每天上下班从拥挤的地铁中挤出来之后再去花费已经少得可怜的业余时间去学习自己不是翻墙根本不需要知道的名词到底是什么意思。于是乎，我们得过且过。不用Google也不会死，对不对。SSH加浏览器设置，搞一搞也就差不多能用就行啦。但是得过且过也越来越不好过了。从最开始的HTTP代理，到后来的SOCKS代理，到最近的OpenVPN，一个个阵亡。普通人可以使用的方式越来越少。博弈的天平远远不是平衡的，而是一边倒。&lt;/p&gt;

&lt;blockquote&gt;GFW用技术的手段达到了四两拨千斤的作用。难道技术上就没有办法用四两拨千斤的方法重新扭转这一边倒的局面吗？&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;http://static.wooyun.org//drops/20151117/2015111702571023031.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;办法肯定是有的。我能想到的趋势是两个。第一个趋势是用更复杂的技术，但是提供更简单的使用方式。简单的HTTP代理，SOCKS明文代理早已阵亡。接下来的斗争需要更复杂的工具。无论是ShadowSocks还是GoAgent都在向这个方向发展。技术越复杂，意味着普通人要学习要配置的成本就越高。每个人按照文档，在自己的PC上配置ABC的方式已经不能满足下一阶段的斗争需要了。我们需要提升手里的武器，站在一个更高的平台上。&lt;/p&gt;

&lt;p&gt;传统的配置方式的共同特点是终端配置。你需要在你的PC浏览器上，各种应用软件里，手机上，平板电脑上做各种各样的配置。这样的终端配置的方式在过去是很方便的。别人提供一个代理，你在浏览器里一设置就好用了。但是在连OpenVPN都被封了的今天，这种终端配置的方式就大大限制了我们的选择。缺点是多方面的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;翻墙的方式受到终端支持的限制。特别是手机和平板电脑，不ROOT不越狱的话，选择就非常有限了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;终端种类繁多，挂一漏万。提供翻墙的工具的人不可能有精力来测试支持所有种类的终端。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果家里有多个笔记本，还有手机等便携设备使用起来就很不方便。躺在床上要刷Twitter的时候，才发现手机的里的OpenVPN帐号已经被封了，新的那个只配置在了电脑里。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最主流的终端是Windows的PC机。但是在Windows上控制底层网络的运作非常不方便。给翻墙工具的作者设置了一个更高的门槛。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;终端一般处于家庭路由器的后面。大多数直穿的穿墙方式都很难在这种网络环境下工作正常。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;把翻墙工具做到路由器上就可以达到实现更复杂的翻墙技术，同时提供极其简单的使用体验。但是路由器的缺陷也是非常明显的。传统的路由器刷OpenWRT等可以定制的第三方系统有如下缺点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;便携不方便，路由器大部分没有电池，也不方便放在包里&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;相比在电脑上装一个软件试试好不好使，额外购买专门用来翻墙的路由器未免试用成本也太高了。如果没有人愿意尝试，更加不会有人来使用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;路由器安装软件不方便。笔者花了大量时间研究OpenWRT的USB刷机方式。虽然技术上有所突破，但是仍然感觉不适合普通人操作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;硬件受限。路由器的CPU都很慢。内存非常小。如果不是用C来编写应用，速度会非常慢。极大地抬高了开发成本。流行的翻墙工具GoAgent和shadowsocks的最初版本都是Python的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有没有既可以获得路由器的好处，又克服了其缺点的解决方案呢？答案是肯定的。手机做为路由器就可以。目前fqrouter已经推出了Android版本，把手机变成了翻墙路由器。一方面，完成了平台的跃升，从终端翻墙变为了路由器翻墙。另外一方面，因为手机的便携，无需额外设备，安装软件简单，而且硬件强大完胜了常规意义上的路由器。使用手机做为路由器之后：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;翻墙方式不再受到终端的限制。只要能接入路由器，就可以翻墙。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;提供翻墙工具的人不需要测试所有的终端是不是支持。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;多种终端可以同时共享一个路由器。无需重复配置。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;路由器基于的Linux操作系统给翻墙工具的作者提供了极大的便利，新的工具可以更容易地被实现出来。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;提供了一定的直穿的可能性。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;iPhone, Windows Phone等设备不需要越狱，也可以通过翻墙路由器享受到shadowsocks等更高级的翻墙工具。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://static.wooyun.org//drops/20151117/2015111702571086274.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;运行在Android上的翻墙工具fqrouter已经在Google Play上架了：&lt;a href=&quot;https://play.google.com/store/apps/details?id=fq.router2&quot;&gt;https://play.google.com/store/apps/details?id=fq.router2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这是趋势一，平台的提升。第二个趋势是去中心化。我相信未来的趋势肯定不是什么境外敌对势力出于不可告人的目的给我们提供翻墙方式。未来的趋势是各自为战的，公开贩卖的各种翻墙服务会被封杀殆尽。我们要确保的底线是，做为个人，在拥有一台国外服务器，然后有一定技术能力的情况下，能够稳定无忧的翻墙。&lt;/p&gt;

&lt;p&gt;在我们能够保证独善其身的前提下，才有可能怎么去达则兼善天下。才有可能以各自为圆心，把服务以P2P的方式扩散给亲朋好友使用。即便是能够有这样的互助网络建立起来，也肯定是一种去中心化的，开源的实现。只有遍地开花，才能避免被连根拔起。&lt;/p&gt;

&lt;p&gt;前面谈到路由器刷第三方固件对于个人来说不是理想的翻墙路由器的实现方式。但是固定部署的路由器却是理想的P2P节点。P2P的一个简化版本是APN，也就是把代理放在国内，然后iPhone等可以简单地使用HTTP未加密方式使用代理。这种部署方式就比较适合刷在固定部署的路由器上。个人可以在自己家里的路由器上部署了代理，然后无论走到哪里都可以通过家里的路由器代理上网。使用路由器固定部署P2P节点的好处是P2P网络可以有更多的稳定接入点。这些刷了OpenWRT等第三方系统安装了P2P节点程序的路由器不会是普通人玩得转的。其意义更多是有技术实力的志愿者，提供自己的家庭路由器，以换得其他方面的方便。&lt;/p&gt;

&lt;p&gt;实现一个P2P的网络的难点有三个：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;代理服务器的容量有限。传统的代理服务器是无法负载很多人同时用1080P看youtube的，因为带宽不够。不要说免费的P2P网络，就是很多付费的代理服务，也无法满足容量要求。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;中心服务器被封IP。TOR做为著名的P2P网络，其主要问题就是要接入其网络需要连接一个中心服务器。这些服务器的IP数量是有限的。GFW会尽一切力量找到这些IP，然后封IP。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;P2P意味着索取与奉献。人人都想这索取，为什么会有人奉献？如果没有一个等价交换做为社区的基础，这个社区是无法长久的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;目前仍然没有理想的P2P翻墙方式出现。但是这是fqrouter的努力方向。&lt;/p&gt;

&lt;blockquote&gt;中心化的翻墙方式，特别是商业贩卖的翻墙服务注定难逃被捕杀殆尽的命运。具有光明未来的翻墙方式必然是去中心化的，松散的，自组织的P2P的。&lt;/blockquote&gt;

&lt;h1 id=&quot;0x01-全面学习gfw&quot;&gt;0x01 全面学习GFW&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;GFW会是一个长期的存在。要学会与之共存，必须先了解GFW是什么。做为局外人，学习GFW有六个角度。渐进的来看分别是：&lt;/p&gt;

&lt;p&gt;首先我们学习到的是WHAT和WHEN。比如说，你经常听到人的议论是“昨天”，“github”被封了。其中的昨天就是WHEN，github就是WHAT。这是学习GFW的最天然，最朴素的角度。在这个方面做得非常极致的是一个叫做&lt;a href=&quot;https://en.greatfire.org/&quot;&gt;greatfire&lt;/a&gt;的网站。这个网站长期监控成千上万个网站和关键词。通过长期监控，不但可以掌握WHAT被封锁了，还可以知道WHEN被封的，WHEN被解封的。&lt;/p&gt;

&lt;p&gt;接下来的角度是WHO。比如说，“方校长”这个人名就经常和GFW同时出现。但是如果仅仅是掌握一个两个人名，然后像某位同志那样天天在twitter上骂一遍那样，除了把这个人名骂成名人之外，没有什么特别的积极意义。我更看好这篇文章“通过分析论文挖掘防火长城(GFW)的技术人员”的思路。通过网络上的公开信息，掌握GFW的哪些方面与哪些人有关系，这些合作者之间又有什么联系。除了大家猜测的将来可以鞭尸之外，对现在也是有积极的意义的。比如关注这些人的研究动态和思想发展，可以猜测GFW的下一步发展方向。比如阅读过去发表的论文，可以了解GFW的技术演进历史，可以从历史中找到一些技术或者管理体制上的缺陷。&lt;/p&gt;

&lt;p&gt;再接下来就是WHY了。github被封之后就常听人说，github这样的技术网站你封它干啥？是什么原因促成了一个网站的被封与解封的？我们做为局外人，真正的原因当然是无从得知的。但是我们可以猜测。基于猜测，可以把不同网站被封，与网络上的舆情时间做关联和分类。我们知道，方校长对于网路舆情监控是有很深入研究的。有一篇论文（Whiskey, Weed, and Wukan on the World Wide Web: On Measuring Censors’ Resources and Motivations）专门讨论监管者的动机的。观测触发被封的事件与实际被封之间的时间关系，也可以推测出一些有趣的现象。比如有人报告，OpenVPN触发的封端口和封IP这样的事情一般都发生在中国的白天。也就是说，GFW背后不光是机器，有一些组件是血肉构成的。&lt;/p&gt;

&lt;p&gt;剩下的两个角度就是对如何翻墙穿墙最有价值的两个角度了：HOW和WHERE。HOW是非常好理解的，就是在服务器和客户端两边抓包，看看一个正常的网络通信，GFW做为中间人，分别给两端在什么时候发了什么包或者过滤掉了什么包。而这些GFW做的动作，无论是过滤还是发伪包又是如何干扰客户端与服务器之间的正常通信的。WHERE是在知道了HOW之后的进一步发展，不但要了解客户端与服务器这两端的情况，更要了解GFW是挂在两端中间的哪一级路由器上做干扰的。在了解到GFW的关联路由器的IP的基础上，可以根据不同的干扰行为，不同的运营商归属做分组，进一步了解GFW的整体部署情况。&lt;/p&gt;

&lt;p&gt;整体上来说，对GFW的研究都是从WHAT和WHEN开始，让偏人文的就去研究WHO和WHY，像我们这样偏工程的就会去研究HOW和WHERE。以上就是全面了解GFW的主体脉络。接下来，我们就要以HOW和WHERE这两个角度去看一看GFW的原理。&lt;/p&gt;

&lt;h1 id=&quot;0x03-gfw的原理&quot;&gt;0x03 GFW的原理&lt;/h1&gt;

&lt;hr /&gt;

&lt;p&gt;要与GFW对抗不能仅仅停留在什么不能访问了，什么可以访问之类的表面现象上。知道youtube不能访问了，对于翻墙来说并无帮助。但是知道GFW是如何让我们不能访问youtube的，则对下一步的翻墙方案的选择和实施具有重大意义。所以在讨论如何翻之前，先要深入原理了解GFW是如何封的。&lt;/p&gt;

&lt;p&gt;总的来说，GFW是一个分布式的入侵检测系统，并不是一个严格意义上的防火墙。不是说每个出入国境的IP包都需要先经过GFW的首可。做为一个入侵检测系统，GFW把你每一次访问facebook都看做一次入侵，然后在检测到入侵之后采取应对措施，也就是常见的连接重置。整个过程一般话来说就是：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.wooyun.org//drops/20151117/2015111702571172873.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;检测有两种方式。一种是人工检测，一种是机器检测。你去国新办网站举报，就是参与了人工检测。在人工检测到不和谐的网站之后，就会采取一些应对方式来防止国内的网民访问该网站。对于这类的封锁，规避检测就不是技术问题了，只能从GFW采取的应对方式上采取反制措施。另外一类检测是机器检测，其检测过程又可以再进一步细分：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.wooyun.org//drops/20151117/2015111702571174079.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;重建&quot;&gt;重建&lt;/h2&gt;

&lt;p&gt;重建是指GFW从网络上监听过往的IP包，然后分析其中的TCP协议，最后重建出一个完整的字节流。分析是在这个重建的字节流上分析具体的应用协议，比如HTTP协议。然后在应用协议中查找是不是有不和谐的内容，然后决定采用何种应对方式。&lt;/p&gt;

&lt;p&gt;所以，GFW机器检测的第一步就是重建出一个字节流。那么GFW是如何拿到原始的IP包的呢？真正的GFW部署方式，外人根本无从得知。据猜测，GFW是部署在国家的出口路由器的旁路上，用“分光”的方式把IP包复制一份到另外一根光纤上，从而拿到所有进出国境的IP包。下图引在gfwrev.blogspot.com：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.wooyun.org//drops/20151117/2015111702571116045.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但是Google在北京有自己的机房。所以聪明的网友就使用Google的北京机房提供的GAE服务，用Goagent软件达到高速翻墙的目的。但是有网友证实（&lt;a href=&quot;https://twitter.com/chengr28/status/260970749190365184&quot;&gt;https://twitter.com/chengr28/status/260970749190365184&lt;/a&gt;），即便是北京的机房也会被骨干网丢包。事实上Google在北京的谷翔机房有一个独立的AS（BGP的概念）。这个AS与谷歌总部有一条IPV6的直连线路，所以通过这个机房可以用IPV6不受墙的限制出去。但是这个AS无论是连接国内还是国外都是要经过GFW的。所以机房在北京也不能保证国内访问不被墙。GFW通过配置骨干网的BGP路由规则，是可以让国内的机房也经过它的。另外一个例子是当我们访问被封的网站触发连接重置的时候，往往收到两个RST包，但是TTL不同。还有一个例子是对于被封的IP，访问的IP包还没有到达国际出口就已经被丢弃。所以GFW应该在其他地方也部署有设备，据推测是在省级骨干路由的位置。&lt;/p&gt;

&lt;p&gt;对于GFW到底在哪这个话题，最近又有国外友人表达了兴趣（&lt;a href=&quot;https://github.com/mothran/mongol&quot;&gt;https://github.com/mothran/mongol&lt;/a&gt;）。笔者在前人的基础上写了一个更完备的探测工具&lt;a href=&quot;https://github.com/fqrouter/qiang&quot;&gt;https://github.com/fqrouter/qiang&lt;/a&gt;。其原理是基于一个IP协议的特性叫TTL。TTL是Time to Live的简写。IP包在没经过一次路由的时候，路由器都会把IP包的TTL减去1。如果TTL到零了，路由器就不会再把IP包发给下一级路由。然后我们知道GFW会在监听到不和谐的IP包之后发回RST包来重置TCP连接。那么通过设置不同的TTL就可以知道从你的电脑，到GFW之间经过了几个路由器。比如说TTL设置成9不触发RST，但是10就触发RST，那么到GFW就是经过了10个路由器。另外一个IP协议的特性是当TTL耗尽的时候，路由器应该发回一个TTL EXCEEDED的ICMP包，并把自己的IP地址设置成SRC（来源）。结合这两点，就可以探测出IP包是到了IP地址为什么的路由器之后才被GFW检测到。有了IP地址之后，再结合IP地址地理位置的数据库就可以知道其地理位置。据说，得出的位置大概是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.wooyun.org//drops/20151117/2015111702571118944.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但是这里检测出来的IP到底是GFW的还是骨干路由器的？更有可能的是骨干路由器的IP。GFW做为一个设备用“分光”的方式挂在主干路由器旁边做入侵检测。无论如何，GFW通过某种神奇的方式，可以拿到你和国外服务器之间来往的所有的IP包，这点是肯定的。更严谨的理论研究有：&lt;a href=&quot;http://pam2011.gatech.edu/papers/pam2011--Xu.pdf&quot;&gt;Internet Censorship in China: Where Does the Filtering Occur?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;GFW在拥有了这些IP包之后，要做一个艰难的决定，那就是到底要不要让你和服务器之间的通信继续下去。GFW不能太过于激进，毕竟全国性的不能访问国外的网站是违反GFW自身存在价值的。GFW就需要在理解了IP包背后代表的含义之后，再来决定是不是可以安全的阻断你和国外服务器之间的连接。这种理解就要建立了前面说的“重建”这一步的基础上。大概用图表达一下重建是在怎么一回事：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.wooyun.org//drops/20151117/2015111702571192283.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;重建需要做的事情就是把IP包1中的GET /inde和IP包2中的x.html H和IP包3中的TTP/1.1拼到一起变成GET /index.html HTTP/1.1。拼出来的数据可能是纯文本的，也可能是二进制加密的协议内容。具体是什么是你和服务器之间约定好的。GFW做为窃听者需要猜测才知道你们俩之间的交谈内容。对于HTTP协议就非常容易猜测了，因为HTTP的协议是标准化的，而且是未加密的。所以GFW可以在重建之后很容易的知道，你使用了HTTP协议，访问的是什么网站。&lt;/p&gt;

&lt;p&gt;重建这样的字节流有一个难点是如何处理巨大的流量？这个问题在这篇博客（&lt;a href=&quot;http://gfwrev.blogspot.tw/2010/02/gfw.html&quot;&gt;http://gfwrev.blogspot.tw/2010/02/gfw.html&lt;/a&gt;）中已经讲得很明白了。其原理与网站的负载均衡器一样。对于给定的来源和目标，使用一个HASH算法取得一个节点值，然后把所有符合这个来源和目标的流量都往这个节点发。所以在一个节点上就可以重建一个TCP会话的单向字节流。&lt;/p&gt;

&lt;p&gt;最后为了讨论完整，再提两点。虽然GFW的重建发生在旁路上是基于分光来实现的，但并不代表整个GFW的所有设备都在旁路。后面会提到有一些GFW应对形式必须是把一些GFW的设备部署在了主干路由上，比如对Google的HTTPS的间歇性丢包，也就是GFW是要参与部分IP的路由工作的。另外一点是，重建是单向的TCP流，也就是GFW根本不在乎双向的对话内容，它只根据监听到的一个方向的内容然后做判断。但是监听本身是双向的，也就是无论是从国内发到国外，还是从国外发到国内，都会被重建然后加以分析。所以一个TCP连接对于GFW来说会被重建成两个字节流。具体的证据会在后面谈如何直穿GFW中详细讲解。&lt;/p&gt;

&lt;h2 id=&quot;分析&quot;&gt;分析&lt;/h2&gt;

&lt;p&gt;分析是GFW在重建出字节流之后要做的第二步。对于重建来说，GFW主要处理IP协议，以及上一层的TCP和UDP协议就可以了。但是对于分析来说，GFW就需要理解各种各样的应用层的稀奇古怪的协议了。甚至，我们也可以自己发明新的协议。&lt;/p&gt;

&lt;p&gt;总的来说，GFW做协议分析有两个相似，但是不同的目的。第一个目的是防止不和谐内容的传播，比如说使用Google搜索了“不该”搜索的关键字。第二个目的是防止使用翻墙工具绕过GFW的审查。下面列举一些已知的GFW能够处理的协议。&lt;/p&gt;

&lt;p&gt;对于GFW具体是怎么达到目的一，也就是防止不和谐内容传播的就牵涉到对HTTP协议和DNS协议等几个协议的明文审查。大体的做法是这样的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.wooyun.org//drops/20151117/2015111702571240415.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;像HTTP这样的协议会有非常明显的特征供检测，所以第一步就没什么好说的了。当GFW发现了包是HTTP的包之后就会按照HTTP的协议规则拆包。这个拆包过程是GFW按照它对于协议的理解来做的。比如说，从HTTP的GET请求中取得请求的URL。然后GFW拿到这个请求的URL去与关键字做匹配，比如查找Twitter是否在请求的URL中。为什么有拆包这个过程？首先，拆包之后可以更精确的打击，防止误杀。另外可能预先做拆包，比全文匹配更节省资源。其次，xiaoxia和liruqi同学的&lt;a href=&quot;https://github.com/liruqi/jjproxy&quot;&gt;jjproxy&lt;/a&gt;的核心就是基于GFW的一个HTTP拆包的漏洞，当然这个bug已经被修复了。其原理就是GFW在拆解HTTP包的时候没有处理有多出来的\r\n这样的情况，但是你访问的google.com却可以正确处理额外的\r\n的情况。从这个例子中可以证明，GFW还是先去理解协议，然后才做关键字匹配的。关键字匹配应该就是使用了一些高效的正则表达式算法，没有什么可以讨论的。&lt;/p&gt;

&lt;p&gt;HTTP代理和SOCKS代理，这两种明文的代理都可以被GFW识别。之前笔者认为GFW可以在识别到HTTP代理和SOCKS代理之后，再拆解其内部的HTTP协议的正文。也就是做两次拆包。但是分析发现，HTTP代理的关键字列表和HTTP的关键字列表是不一样的，所以笔者现在认为HTTP代理协议和SOCKS代理协议是当作单独的协议来处理的，并不是拆出载荷的HTTP请求再进行分析的。&lt;/p&gt;

&lt;p&gt;目前已知的GFW会做的协议分析如下：&lt;/p&gt;

&lt;h3 id=&quot;dns-查询&quot;&gt;DNS 查询&lt;/h3&gt;

&lt;p&gt;GFW可以分析53端口的UDP协议的DNS查询。如果查询的域名匹配关键字则会被DNS劫持。可以肯定的是，这个匹配过程使用的是类似正则的机制，而不仅仅是一个黑名单，因为子域名实在太多了。证据是：2012年11月9日下午3点半开始，防火长城对Google的泛域名 .google.com 进行了大面积的污染，所有以 .google.com 结尾的域名均遭到污染而解析错误不能正常访问，其中甚至包括不存在的域名（来源&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E5%8A%AB%E6%8C%81&quot;&gt;http://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E5%8A%AB%E6%8C%81&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;目前为止53端口之外的查询也没有被劫持。但是TCP的DNS查询已经可以被TCP RST切断了，表明了GFW具有这样的能力，只是不屑于大规模部署。而且TCP查询的关键字比UDP劫持的域名要少的多。目前只有dl.dropbox.com会触发TCP RST。相关的研究论文有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://drops.wooyun.org/&quot;&gt;Hold-On: Protecting Against On-Path DNS Poisoning&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://cs.nyu.edu/~pcw216/work/nds/final.pdf&quot;&gt;The Great DNS Wall of China&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;http-请求&quot;&gt;HTTP 请求&lt;/h3&gt;

&lt;p&gt;GFW可以识别出HTTP协议，并且检查GET的URL与HOST。如果匹配了关键字则会触发TCP RST阻断。前面提到了jjproxy使用的构造特殊的HTTP GET请求欺骗GFW的做法已经失效，现在GFW只要看到\r\n就直接TCP RST阻断了（来源&lt;a href=&quot;https://plus.google.com/u/0/108661470402896863593/posts/6U6Q492M3yY&quot;&gt;https://plus.google.com/u/0/108661470402896863593/posts/6U6Q492M3yY&lt;/a&gt;）。相关的研究论文有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.internetfreedom.org/files/WhitePaper/ChinaGreatFirewallRevealed.pdf&quot;&gt;The Great Firewall Revealed&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.cl.cam.ac.uk/~rnc1/ignoring.pdf&quot;&gt;Ignoring the Great Firewall of China&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://gfwrev.blogspot.com/2010/03/http-url.html&quot;&gt;HTTP URL/深度关键字检测&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.csd.uoc.gr/~hy558/papers/conceptdoppler.pdf&quot;&gt;ConceptDoppler: A Weather Tracker for Internet Censorship&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;http-响应&quot;&gt;HTTP 响应&lt;/h3&gt;

&lt;p&gt;GFW除了会分析上行的HTTP GET请求，对于HTTP返回的内容也会做全文关键字检查。这种检查与对请求的关键字检查不是由同一设备完成的，而且对GFW的资源消耗也更大。相关的研究论文有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.191.206&amp;amp;rep=rep1&amp;amp;type=pdf&quot;&gt;Empirical Study of a National-Scale Distributed Intrusion Detection System: Backbone-Level Filtering of HTML Responses in China&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;http代理协议&quot;&gt;HTTP代理协议&lt;/h3&gt;

&lt;p&gt;TODO&lt;/p&gt;

&lt;h3 id=&quot;socks45代理协议&quot;&gt;SOCKS4/5代理协议&lt;/h3&gt;

&lt;p&gt;TODO&lt;/p&gt;

&lt;h3 id=&quot;smtp-协议&quot;&gt;SMTP 协议&lt;/h3&gt;

&lt;p&gt;因为有很多翻墙软件都是以邮件索取下载地址的方式发布的，所以GFW有针对性的封锁了SMTP协议，阻止这样的邮件往来。&lt;/p&gt;

&lt;p&gt;封锁有三种表现方式（&lt;a href=&quot;http://fqrouter.tumblr.com/post/43400982633/%E8%AF%A6%E8%BF%B0gfw%E5%AF%B9smtp%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%89%E7%A7%8D%E5%B0%81%E9%94%81%E6%89%8B%E6%B3%95&quot;&gt;http://fqrouter.tumblr.com/post/43400982633/gfw-smtp&lt;/a&gt;），简单概要的说就是看邮件是不是发往上了黑名单的邮件地址的（比如xiazai@upup.info就是一个上了黑名单的邮件地址），如果发现了就立马用TCP RST包切断连接。&lt;/p&gt;

&lt;h3 id=&quot;电驴ed2k协议&quot;&gt;电驴(ed2k)协议&lt;/h3&gt;

&lt;p&gt;GFW还会过滤电驴（ed2k）协议中的查询内容。因为ed2k还有一个混淆模式，会加密往来的数据包，GFW会切断所有使用混淆模式的ed2k连接，迫使客户端使用明文与服务器通讯（&lt;a href=&quot;http://fqrouter.tumblr.com/post/43490772120/gfw%E5%AF%B9ed2k%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%AE%9A%E7%82%B9%E6%B8%85%E9%99%A4&quot;&gt;http://fqrouter.tumblr.com/post/43490772120/gfw-ed2k&lt;/a&gt;）。然后如果客户端发起了搜索请求，查找的关键字中包含敏感词的话就会被用TCP RST包切断连接。&lt;/p&gt;

&lt;h3 id=&quot;对翻墙流量的分析识别&quot;&gt;对翻墙流量的分析识别&lt;/h3&gt;

&lt;p&gt;GFW的第二个目的是封杀翻墙软件。为了达到这个目的GFW采取的手段更加暴力。原因简单，对于HTTP协议的封杀如果做不好会影响互联网的正常运作，GFW与互联网是共生的关系，它不会做威胁自己存在的事情。但是对于TOR这样的几乎纯粹是为翻墙而存在的协议，只要检测出来就是格杀勿论的了。GFW具体是如何封杀各种翻墙协议的，我也不是很清楚，事态仍然在不断更新中。但是举两个例子来证明GFW的高超技术。&lt;/p&gt;

&lt;p&gt;第一个例子是GFW对TOR的自动封杀，体现了GFW尽最大努力去理解协议本身。根据这篇博客（&lt;a href=&quot;https://blog.torproject.org/blog/knock-knock-knockin-bridges-doors&quot;&gt;https://blog.torproject.org/blog/knock-knock-knockin-bridges-doors&lt;/a&gt;）。使用中国的IP去连接一个美国的TOR网桥，会被GFW发现。然后GFW回头（15分钟之后）会亲自假装成客户端，用TOR的协议去连接那个网桥。如果确认是TOR的网桥，则会封当时的那个端口。换了端口之后，可以用一段时间，然后又会被封。这表现出了GFW对于协议的高超检测能力，可以从国际出口的流量中敏锐地发现你连接的TOR网桥。据TOR的同志说是因为TOR协议中的握手过程具有太明显的特征了。另外一点就表现了GFW的不辞辛劳，居然会自己伪装成客户端过去连连看。&lt;/p&gt;

&lt;p&gt;第二个例子表现了GFW根本不在乎加密的流量中的具体内容是不是有敏感词。只要疑似翻墙，特别是提供商业服务给多个翻墙，就会被封杀。根据这个帖子（&lt;a href=&quot;http://www.v2ex.com/t/55531&quot;&gt;http://www.v2ex.com/t/55531&lt;/a&gt;），使用的ShadowSocks协议。预先部署密钥，没有明显的握手过程仍然被封。据说是GFW已经升级为能够机器识别出哪些加密的流量是疑似翻墙服务的。&lt;/p&gt;

&lt;p&gt;关于GFW是如何识别与封锁翻墙服务器的，最近写了一篇文章提出我的猜想，大家可以去看看：&lt;a href=&quot;http://fqrouter.tumblr.com/post/45969604783/gfw&quot;&gt;http://fqrouter.tumblr.com/post/45969604783/gfw&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;最近发现GFW对OpenVPN和SSL证书已经可以做到准实时的封IP（端口）。原理应该是离线做的深包分析，然后提取出可疑的IP列表，经过人工确认之后封IP。因为OpenVPN有显著的协议的特征，而且基本不用于商业场景所以很容易确认是翻墙服务。但是SSL也就是HTTPS用的加密协议也能基于“证书”做过滤不得不令人感到敬畏了。Shadowsocks的作者Clowwindy为此专门撰文“为什么不应该用SSL翻墙“：&lt;a href=&quot;https://gist.github.com/clowwindy/5947691&quot;&gt;https://gist.github.com/clowwindy/5947691&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;总结起来就是，GFW已经基本上完成了目的一的所有工作。明文的协议从HTTP到SMTP都可以分析然后关键字检测，甚至电驴这样不是那么大众的协议GFW都去搞了。从原理上来说也没有什么好研究的，就是明文，拆包，关键字。GFW显然近期的工作重心在分析网络流量上，从中识别出哪些是翻墙的流量。这方面的研究还比较少，而且一个显著的特征是自己用没关系，大规模部署就容易出问题。我目前没有在GFW是如何封翻墙工具上有太多研究，只能是道听途说了。&lt;/p&gt;

&lt;h2 id=&quot;应对&quot;&gt;应对&lt;/h2&gt;

&lt;p&gt;GFW的应对措施是三步中最明显的，因为它最直接。GFW的重建过程和协议分析的过程需要耐心的试探才能大概推测出GFW是怎么实现的。但是GFW的应对手段我们每天都可以见到，比如连接重置。GFW的应对目前可以感受到的只有一个目的就是阻断。但是从广义上来说，应对方式应该不限于阻断。比如说记录下日志，然后做统计分析，秋后算账什么的也可以算是一种应对。就阻断方式而言，其实并不多，那么我们一个个来列举吧。&lt;/p&gt;

&lt;h3 id=&quot;封ip&quot;&gt;封IP&lt;/h3&gt;

&lt;p&gt;一般常见于人工检测之后的应对。还没有听说有什么方式可以直接使得GFW的机器检测直接封IP。一般常见的现象是GFW机器检测，然后用TCP RST重置来应对。过了一段时间才会被封IP，而且没有明显的时间规律。所以我的推测是，全局性的封IP应该是一种需要人工介入的。注意我强调了全局性的封IP，与之相对的是部分封IP，比如只对你访问那个IP封个3分钟，但是别人还是可以访问这样的。这是一种完全不同的封锁方式，虽然现象差不多，都是ping也ping不通。要观摩的话ping twitter.com就可以了，都封了好久了。&lt;/p&gt;

&lt;p&gt;其实现方式是把无效的路由黑洞加入到主干路由器的路由表中，然后让这些主干网上的路由器去帮GFW把到指定IP的包给丢弃掉。路由器的路由表是动态更新的，使用的协议是BGP协议。GFW只需要维护一个被封的IP列表，然后用BGP协议广播出去就好了。然后国内主干网上的路由器都好像变成了GFW的一份子那样，成为了帮凶。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.wooyun.org//drops/20151117/2015111702571271670.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果我们使用traceroute去检查这种被全局封锁的IP就可以发现，IP包还没有到GFW所在的国际出口就已经被电信或者联通的路由器给丢弃了。这就是BGP广播的作用了。&lt;/p&gt;

&lt;h3 id=&quot;dns劫持&quot;&gt;DNS劫持&lt;/h3&gt;

&lt;p&gt;这也是一种常见的人工检测之后的应对。人工发现一个不和谐网站，然后就把这个网站的域名给加到劫持列表中。其原理是基于DNS与IP协议的弱点，DNS与IP这两个协议都不验证服务器的权威性，而且DNS客户端会盲目地相信第一个收到的答案。所以你去查询facebook.com的话，GFW只要在正确的答案被返回之前抢答了，然后伪装成你查询的DNS服务器向你发错误的答案就可以了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.wooyun.org//drops/20151117/2015111702571253840.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;tcp-rst阻断&quot;&gt;TCP RST阻断&lt;/h3&gt;

&lt;p&gt;TCP协议规定，只要看到RST包，连接立马被中断。从浏览器里来看就是连接已经被重置。我想对于这个错误大家都不陌生。据我个人观感，这种封锁方式是GFW目前的主要应对手段。大部分的RST是条件触发的，比如URL中包含某些关键字。目前享受这种待遇的网站就多得去了，著名的有facebook。还有一些网站，会被无条件RST。也就是针对特定的IP和端口，无论包的内容就会触发RST。比较著名的例子是https的wikipedia。GFW在TCP层的应对是利用了IPv4协议的弱点，也就是只要你在网络上，就假装成任何人发包。所以GFW可以很轻易地让你相信RST确实是Google发的，而让Google相信RST是你发的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.wooyun.org//drops/20151117/2015111702571298497.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;封端口&quot;&gt;封端口&lt;/h3&gt;

&lt;p&gt;GFW除了自身主体是挂在骨干路由器旁路上的入侵检测设备，利用分光技术从这个骨干路由器抓包下来做入侵检测 (所谓 IDS)，除此之外这个路由器还会被用来封端口 (所谓 IPS)。GFW在检测到入侵之后可以不仅仅可以用TCP RST阻断当前这个连接，而且利用骨干路由器还可以对指定的IP或者端口进行从封端口到封IP，设置选择性丢包的各种封禁措施。可以理解为骨干路由器上具有了类似“iptables”的能力（网络层和传输层的实时拆包，匹配规则的能力）。这个iptables的能力在CISCO路由器上叫做ACL Based Forwarding (ABF)。而且规则的部署是全国同步的，一台路由器封了你的端口，全国的挂了GFW的骨干路由器都会封。一般这种封端口都是针对翻墙服务器的，如果检测到服务器是用SSH或者VPN等方式提供翻墙服务。GFW会在全国的出口骨干路由上部署这样的一条ACL规则，来封你这个服务器+端口的下行数据包。也就是如果包是从国外发向国内的，而且src（源ip）是被封的服务器ip，sport（源端口）是被封的端口，那么这个包就会被过滤掉。这样部署的规则的特点是，上行的数据包是可以被服务器收到的，而下行的数据包会被过滤掉。&lt;/p&gt;

&lt;p&gt;如果被封端口之后服务器采取更换端口的应对措施，很快会再次被封。而且多次尝试之后会被封IP。初步推断是，封端口不是GFW的自动应对行为，而是采取黑名单加人工过滤地方式实现的。一个推断的理由就是网友报道，封端口都是发生在白天工作时间。&lt;/p&gt;

&lt;p&gt;在进入了封端口阶段之后，还会有继发性的临时性封其他端口的现象，但是这些继发性的封锁具有明显的超时时间，触发了之后（触发条件不是非常明确）会立即被封锁，然后过了一段时间就自动解封。目前对于这一波封SSH/OPENVPN采用的以封端口为明显特征的封锁方式研究尚不深入。可以参考我最近写的一篇文章：&lt;a href=&quot;http://fqrouter.tumblr.com/post/45969604783/gfw&quot;&gt;http://fqrouter.tumblr.com/post/45969604783/gfw&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.wooyun.org//drops/20151117/2015111702571226679.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;https间歇性丢包&quot;&gt;HTTPS间歇性丢包&lt;/h3&gt;

&lt;p&gt;对于Google的HTTPS服务，GFW不愿意让其完全不能访问。所以采取的办法是对于Google的某些IP的443端口采取间歇性丢包的措施。最明显的ip段是国内解析google域名常见的74.125.128.*。其原理应该类似于封端口，是在骨干路由器上做的丢包动作。但是触发条件并不只是看IP和端口，加上了时间间隔这样一个条件。&lt;/p&gt;

&lt;h1 id=&quot;0x03-翻墙原理&quot;&gt;0x03 翻墙原理&lt;/h1&gt;

&lt;p&gt;前面从原理上讲解了GFW的运作原理。翻墙的原理与之相对应，分为两大类。第一类是大家普遍的使用的绕道的方式。IP包经由第三方中转已加密的形式通过GFW的检查。这样的一种做法更像“翻”墙，是从墙外绕过去的。第二类是找出GFW检测过程的中一些BUG，利用这些BUG让GFW无法知道准确的会话内容从而放行。这种做法更像“穿”墙。曾经引起一时轰动的西厢计划第一季就是基于这种方式的实现。&lt;/p&gt;

&lt;p&gt;基于绕道法的翻墙方式无论是VPN还是SOCKS代理，原理都是类似的。都是以国外有一个代理服务器为前提，然后你与代理服务器通信，代理服务器再与目标服务器通信。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.wooyun.org//drops/20151117/2015111702571362513.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;绕道法对于IP封锁来说，因为最终的IP包是由代理服务器在墙外发出的，所以国内骨干路由封IP并不会产生影响。对于TCP重置来说，因为TCP重置是以入侵检测为前提的，客户端与代理之间的加密通信规避了入侵检测，使得TCP重置不会被触发。&lt;/p&gt;

&lt;p&gt;但是对于反DNS污染来说，VPN和SOCKS代理却有不同。基于VPN的翻墙方法，得到正确的DNS解析的结果需要设置一个国外的没有被污染的DNS服务器。然后发UDP请求去解析域名的时候，VPN会用绕道的方式让UDP请求不被劫持地通过GFW。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.wooyun.org//drops/20151117/2015111702571364142.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但是SOCKS代理和HTTP代理这些更上层的代理协议则可以选择不同的方式。因为代理与应用之间有更紧密的关系，应用程序比如浏览器可以把要访问的服务器的域名直接告诉本地的代理。然后SOCKS代理可以选择不在本地做解析，直接把请求发给墙外的代理服务器。在代理服务器去与目标服务器做连接的时候再在代理服务器上做DNS解析，从而避开了GFW的DNS劫持。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.wooyun.org//drops/20151117/2015111702571343558.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;VPN与SOCKS代理的另外一个主要区别是应用程序是如何使用上代理去访问国外的服务器的。先来看不加代理的时候，应用程序是如何访问网络的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.wooyun.org//drops/20151117/2015111702571384358.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;应用程序把IP包交给操作系统，操作系统会去决定把包用机器上的哪块网卡发出去。VPN的客户端对于操作系统来说就是一个虚拟出来的网卡。应用程序完全不用知道VPN客户端的存在，操作系统甚至也不需要区分VPN客户端与普通网卡的区别。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.wooyun.org//drops/20151117/2015111702571360138.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;VPN客户端在启动之后会把操作系统的缺省路由改成自己。这样所有的IP包都会经由这块虚拟的网卡发出去。这样VPN就能够再打包成加密的流量发出去（当然线路还是之前的电信线路），发回去的加密流量再解密拆包交还给操作系统。&lt;/p&gt;

&lt;p&gt;SOCKS代理等应用层的代理则不同。其流量走不走代理的线路并不是由操作系统使用路由表选择网卡来决定的，而是在应用程序里自己做的。也就是说，对于操作系统来说，使用SOCKS代理的TCP连接和不使用SOCKS代理的TCP连接并没有任何的不同。应用程序自己去选择是直接与目标服务器建立连接，还是与SOCKS代理服务器建立TCP连接，然后由SOCKS代理服务器去建立第二个TCP连接，两个TCP连接的数据由代理服务器中转。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.wooyun.org//drops/20151117/2015111702571486027.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;关于VPN/SOCKS代理，可以参见我博客上的文章：&lt;a href=&quot;http://fqrouter.tumblr.com/post/51474945203/socks-vpn&quot;&gt;http://fqrouter.tumblr.com/post/51474945203/socks-vpn&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;绕道法的翻墙原理就是这些了，相对来说非常简单。其针对的都是GFW的分析那一步，通过加密使得GFW无法分析出流量的原文从而让GFW放行。但是GFW最近的升级表明，GFW虽然无法解密这些加密的流量，但是GFW可以结合流量与其他协议特征探测出这些流量是不是“翻墙”的，然后就直接暴力的切断。绕道法的下一步发展就是要从原理弄明白，GFW是如何分析出翻墙流量的，从而要么降低自身的流量特征避免上短名单被协议分析，或者通过混淆协议把自己伪装成其他的无害流量。&lt;/p&gt;

&lt;h1 id=&quot;0x04-穿墙原理&quot;&gt;0x04 穿墙原理&lt;/h1&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;实验环境准备&quot;&gt;实验环境准备&lt;/h2&gt;

&lt;p&gt;穿墙比翻墙要复杂得多，但也有意思得多。本章节以实验为主。实验的设备是家庭用的路由器，我用的是水星4530R。需要有公网IP。刷的操作系统是OpenWRT Attitude Adjustment 12.09 rc-1版本。使用的包有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;NetfilterQueue（&lt;a href=&quot;https://github.com/fqrouter/fqrouter&quot;&gt;https://github.com/fqrouter/fqrouter&lt;/a&gt; 中有）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;bind-dig&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;shadow&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;dpkt （不是OpenWRT的包，是python的 &lt;a href=&quot;http://dpkt.googlecode.com/files/dpkt-1.7.tar.gz&quot;&gt;http://dpkt.googlecode.com/files/dpkt-1.7.tar.gz&lt;/a&gt; ）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文并不打算详细讲解实验环境的设置。对于有OpenWRT编译和刷机经验的朋友可能可以按照我的叙述重建出实验环境来。整个实验的关键在于&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;公网上的ip地址&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Linux&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;python&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;python访问netfilter queue的库&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果你有一台公网上的Linux机器，安装了Python和Python的&lt;a href=&quot;https://github.com/fqrouter/python-netfilterqueue&quot;&gt;NetfilterQueue&lt;/a&gt;，也可以进行同样的实验。&lt;/p&gt;

&lt;p&gt;如果你使用的是路由器，需要验证你有公网ip。这个可以访问ifconfig.me来证实。其次要保证路由器是OpenWRT的并且有足够的空间安装python-mini。到这里基本上都和普通的OpenWRT刷机没有什么两样。重点在于：&lt;/p&gt;

&lt;h3 id=&quot;安装python的netfilterqueue&quot;&gt;安装Python的NetfilterQueue&lt;/h3&gt;

&lt;p&gt;OpenWRT提供了NetfilterQueue的C的库。但是使用C来做实验太笨重了。所以我选择了Python。但是Python的NetfilterQueue的库没有在OpenWRT中。下载&lt;a href=&quot;https://github.com/fqrouter/fqrouter&quot;&gt;https://github.com/fqrouter/fqrouter&lt;/a&gt; 解压后可以得到一个名字叫fqrouter的目录。然后给feeds.conf添加一行src-link fqrouter /opt/fqrouter/package。把/opt/fqrouter替换为你解压的目录。然后scripts/feeds update -a，再执行scripts/feeds install python-netfilterqueue就添加好了。然后在make menuconfig中选择Languages=&amp;gt;Python=&amp;gt;python-netfilterqueue。&lt;/p&gt;

&lt;p&gt;有了这个库就赋予了我们使用Python任意抓包，修改包和发包的能力。在OpenWRT上，除了python没有第二种脚本语言可以如此简单地获得这些能力。&lt;/p&gt;

&lt;h3 id=&quot;安装python的dpkt&quot;&gt;安装Python的dpkt&lt;/h3&gt;

&lt;p&gt;能够抓取和发送IP包之后，第二个头疼的问题是如何解析和构造任意的IP包。Python有一个库叫dpkt可以帮我们很好地完成这项任务。这是我们选择Python做实验的第二个重要理由。&lt;/p&gt;

&lt;p&gt;在路由器上直接下载&lt;a href=&quot;http://dpkt.googlecode.com/files/dpkt-1.7.tar.gz&quot;&gt;http://dpkt.googlecode.com/files/dpkt-1.7.tar.gz&lt;/a&gt;，然后解压缩，拷贝其中的dpkt目录到&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/lib/python2.7/site-packages&lt;/code&gt;下。&lt;/p&gt;

&lt;h2 id=&quot;dns劫持观测&quot;&gt;DNS劫持观测&lt;/h2&gt;

&lt;p&gt;我们要做的第一个实验是用python代码观测到DNS劫持的全过程。&lt;/p&gt;

&lt;h3 id=&quot;应用层观测&quot;&gt;应用层观测&lt;/h3&gt;

&lt;p&gt;dig是DNS的客户端，可以很方便地构造出我们想要的DNS请求。&lt;code class=&quot;highlighter-rouge&quot;&gt;dig @8.8.8.8 twitter.com&lt;/code&gt;。可以得到相应如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;; (1 server found)
;; global options: +cmd
;; Got answer:
;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 5494
;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0    

;; QUESTION SECTION:
;twitter.com.                        IN        A    

;; ANSWER SECTION:
twitter.com.                4666        IN        A        59.24.3.173    

;; Query time: 110 msec
;; SERVER: 8.8.8.8#53(8.8.8.8)
;; WHEN: Sun Jan 13 13:22:10 2013
;; MSG SIZE  rcvd: 45
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以很清楚地看到我们得到的错误答案59.24.3.173。&lt;/p&gt;

&lt;h3 id=&quot;抓包观测&quot;&gt;抓包观测&lt;/h3&gt;

&lt;p&gt;使用iptables我们可以让特定的IP包经过应用层的代码，从而使得我们用python观测DNS查询过程提供了可能。代码如下，保存文件名dns_hijacking_obversation.py（&lt;a href=&quot;https://gist.github.com/4524294&quot;&gt;https://gist.github.com/4524294&lt;/a&gt;）：&lt;/p&gt;

&lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;


1




2




3




4




5




6




7




8




9




10




11




12




13




14




15




16




17




18




19




20




21




22




23




24

&lt;/td&gt;

&lt;td&gt;





`from` `netfilterqueue ``import` `NetfilterQueue`




`import` `subprocess`




`import` `signal    `







`def` `observe_dns_hijacking(nfqueue_element):`




`   ``print``(``'packet past through me'``)`




`   ``nfqueue_element.accept()    `







`nfqueue ``=` `NetfilterQueue()`




`nfqueue.bind(``0``, observe_dns_hijacking)    `







`def` `clean_up(``*``args):`




`   ``subprocess.call(``'iptables -D OUTPUT -p udp --dst 8.8.8.8 -j QUEUE'``, shell``=``True``)`




`   ``subprocess.call(``'iptables -D INPUT -p udp --src 8.8.8.8 -j QUEUE'``, shell``=``True``)    `







`signal.signal(signal.SIGINT, clean_up)    `







`try``:`




`   ``subprocess.call(``'iptables -I INPUT -p udp --src 8.8.8.8 -j QUEUE'``, shell``=``True``)`




`   ``subprocess.call(``'iptables -I OUTPUT -p udp --dst 8.8.8.8 -j QUEUE'``, shell``=``True``)`




`   ``print``(``'running..'``)`




`   ``nfqueue.run()`




`except` `KeyboardInterrupt:`




`   ``print``(``'bye'``)`




&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;执行python dns_hijacking_observation.py，再使用dig @8.8.8.8 twitter.com应该可以看到package past through me。这就说明DNS的请求和答案都经过了python代码了。&lt;/p&gt;

&lt;p&gt;上一步主要是验证NetfilterQueue是不是工作正常。这一步则要靠dpkt的了。代码如下，文件名相同（&lt;a href=&quot;https://gist.github.com/4524299&quot;&gt;https://gist.github.com/4524299&lt;/a&gt;）：&lt;/p&gt;

&lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;


1




2




3




4




5




6




7




8




9




10




11




12




13




14




15




16




17




18




19




20




21




22




23




24




25




26




27




28




29




30




31




32




33




34




35




36

&lt;/td&gt;

&lt;td&gt;





`from` `netfilterqueue ``import` `NetfilterQueue`




`import` `subprocess`




`import` `signal`




`import` `dpkt`




`import` `traceback`




`import` `socket    `







`def` `observe_dns_hijacking(nfqueue_element):`




`   ``try``:`




`       ``ip_packet ``=` `dpkt.ip.IP(nfqueue_element.get_payload())`




`       ``dns_packet ``=` `dpkt.dns.DNS(ip_packet.udp.data)`




`       ``print``(``repr``(dns_packet))`




`       ``for` `answer ``in` `dns_packet.an:`




`           ``print``(socket.inet_ntoa(answer[``'rdata'``]))`




`       ``nfqueue_element.accept()`




`   ``except``:`




`       ``traceback.print_exc()`




`       ``nfqueue_element.accept()    `







`nfqueue ``=` `NetfilterQueue()`




`nfqueue.bind(``0``, observe_dns_hijacking)    `







`def` `clean_up(``*``args):    `







`   ``subprocess.call(``'iptables -D OUTPUT -p udp --dst 8.8.8.8 -j QUEUE'``, shell``=``True``)`




`   ``subprocess.call(``'iptables -D INPUT -p udp --src 8.8.8.8 -j QUEUE'``, shell``=``True``)    `







`signal.signal(signal.SIGINT, clean_up)    `







`try``:`




`   ``subprocess.call(``'iptables -I INPUT -p udp --src 8.8.8.8 -j QUEUE'``, shell``=``True``)`




`   ``subprocess.call(``'iptables -I OUTPUT -p udp --dst 8.8.8.8 -j QUEUE'``, shell``=``True``)`




`   ``print``(``'running..'``)`




`   ``nfqueue.run()`




`except` `KeyboardInterrupt:`




`   ``print``(``'bye'``)`




&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;执行python dns_hijacking_observation.py，再使用dig @8.8.8.8 twitter.com应该可以看到类似如下的输出：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DNS(ar=[RR(type=41, cls=4096)], qd=[Q(name='twitter.com')], id=8613, op=288)
DNS(an=[RR(name='twitter.com', rdata=';\x18\x03\xad', ttl=19150)], qd=[Q(name='twitter.com')], id=8613, op=33152)
59.24.3.173
DNS(an=[RR(name='twitter.com', rdata='\xc7;\x95\xe6', ttl=27), RR(name='twitter.com', rdata='\xc7;\x96\x07', ttl=27), RR(name='twitter.com', rdata=&quot;\xc7;\x96'&quot;, ttl=27)], ar=[RR(type=41, cls=512)], qd=[Q(name='twitter.com')], id=8613, op=33152)
199.59.149.230
199.59.150.7
199.59.150.39
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到我们发出去了一个包，收到了两个包。其中第一个收到的包是GFW发回来的错误答案，第二个包才是正确的答案。但是由于dig只取第一个返回的答案，所以我们实际看到的解析结果是错误的。&lt;/p&gt;

&lt;h3 id=&quot;观测劫持发生的位置&quot;&gt;观测劫持发生的位置&lt;/h3&gt;

&lt;p&gt;利用IP包的TTL特性，我们可以把TTL值从1开始递增，直到我们收到错误的应答为止。结合TTL EXECEEDED ICMP返回的IP地址，就可以知道DNS请求是在第几跳的路由器分光给GFW的。代码如下（&lt;a href=&quot;https://gist.github.com/4524927&quot;&gt;https://gist.github.com/4524927&lt;/a&gt;）：&lt;/p&gt;

&lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;


1




2




3




4




5




6




7




8




9




10




11




12




13




14




15




16




17




18




19




20




21




22




23




24




25




26




27




28




29




30




31




32




33




34




35




36




37




38




39




40




41




42




43




44




45




46




47




48




49




50




51




52




53




54




55




56




57




58




59




60




61




62




63




64




65




66




67




68




69




70




71




72




73




74




75




76




77




78




79




80




81




82




83




84




85




86




87




88




89




90




91




92




93




94




95




96

&lt;/td&gt;

&lt;td&gt;





`from` `netfilterqueue ``import` `NetfilterQueue`




`import` `subprocess`




`import` `signal`




`import` `dpkt`




`import` `traceback`




`import` `socket`




`import` `sys    `







`DNS_IP ``=` `'8.8.8.8'`







`# source http://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93`




`WRONG_ANSWERS ``=` `{`




`   ``'4.36.66.178'``,`




`   ``'8.7.198.45'``,`




`   ``'37.61.54.158'``,`




`   ``'46.82.174.68'``,`




`   ``'59.24.3.173'``,`




`   ``'64.33.88.161'``,`




`   ``'64.33.99.47'``,`




`   ``'64.66.163.251'``,`




`   ``'65.104.202.252'``,`




`   ``'65.160.219.113'``,`




`   ``'66.45.252.237'``,`




`   ``'72.14.205.99'``,`




`   ``'72.14.205.104'``,`




`   ``'78.16.49.15'``,`




`   ``'93.46.8.89'``,`




`   ``'128.121.126.139'``,`




`   ``'159.106.121.75'``,`




`   ``'169.132.13.103'``,`




`   ``'192.67.198.6'``,`




`   ``'202.106.1.2'``,`




`   ``'202.181.7.85'``,`




`   ``'203.161.230.171'``,`




`   ``'207.12.88.98'``,`




`   ``'208.56.31.43'``,`




`   ``'209.36.73.33'``,`




`   ``'209.145.54.50'``,`




`   ``'209.220.30.174'``,`




`   ``'211.94.66.147'``,`




`   ``'213.169.251.35'``,`




`   ``'216.221.188.182'``,`




`   ``'216.234.179.13'`




`}    `







`current_ttl ``=` `1`







`def` `locate_dns_hijacking(nfqueue_element):`




`   ``global` `current_ttl`




`   ``try``:`




`       ``ip_packet ``=` `dpkt.ip.IP(nfqueue_element.get_payload())`




`       ``if` `dpkt.ip.IP_PROTO_ICMP ``=``=` `ip_packet[``'p'``]:`




`           ``print``(socket.inet_ntoa(ip_packet.src))`




`       ``elif` `dpkt.ip.IP_PROTO_UDP ``=``=` `ip_packet[``'p'``]:`




`           ``if` `DNS_IP ``=``=` `socket.inet_ntoa(ip_packet.dst):`




`               ``ip_packet.ttl ``=` `current_ttl`




`               ``current_ttl ``+``=` `1`




`               ``ip_packet.``sum` `=` `0`




`               ``nfqueue_element.set_payload(``str``(ip_packet))`




`           ``else``:`




`               ``if` `contains_wrong_answer(dpkt.dns.DNS(ip_packet.udp.data)):`




`                   ``sys.stdout.write(``'* '``)`




`                   ``sys.stdout.flush()`




`                   ``nfqueue_element.drop()`




`                   ``return`




`               ``else``:`




`                   ``print``(``'END'``)`




`       ``nfqueue_element.accept()`




`   ``except``:`




`       ``traceback.print_exc()`




`       ``nfqueue_element.accept()    `







`def` `contains_wrong_answer(dns_packet):`




`   ``for` `answer ``in` `dns_packet.an:`




`       ``if` `socket.inet_ntoa(answer[``'rdata'``]) ``in` `WRONG_ANSWERS:`




`           ``return` `True`




`   ``return` `False`







`nfqueue ``=` `NetfilterQueue()`




`nfqueue.bind(``0``, locate_dns_hijacking)    `







`def` `clean_up(``*``args):`




`   ``subprocess.call(``'iptables -D OUTPUT -p udp --dst %s -j QUEUE'` `%` `DNS_IP, shell``=``True``)`




`   ``subprocess.call(``'iptables -D INPUT -p udp --src %s -j QUEUE'` `%` `DNS_IP, shell``=``True``)`




`   ``subprocess.call(``'iptables -D INPUT -p icmp -m icmp --icmp-type 11 -j QUEUE'``, shell``=``True``)    `







`signal.signal(signal.SIGINT, clean_up)    `







`try``:`




`   ``subprocess.call(``'iptables -I INPUT -p icmp -m icmp --icmp-type 11 -j QUEUE'``, shell``=``True``)`




`   ``subprocess.call(``'iptables -I INPUT -p udp --src %s -j QUEUE'` `%` `DNS_IP, shell``=``True``)`




`   ``subprocess.call(``'iptables -I OUTPUT -p udp --dst %s -j QUEUE'` `%` `DNS_IP, shell``=``True``)`




`   ``print``(``'running..'``)`




`   ``nfqueue.run()`




`except` `KeyboardInterrupt:`




`   ``print``(``'bye'``)`




&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;dig +tries=30 +time=1 @8.8.8.8 twitter.com&lt;/code&gt; 可以得到类似下面的输出：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;=== 隐去 ===
=== 隐去 ===
=== 隐去 ===
219.158.100.166
219.158.11.150
* 219.158.97.30
* * 219.158.27.30
* 72.14.215.130
* 209.85.248.60
* 216.239.43.19
* * END
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;出现*号前面的那个IP就是挂了GFW的路由了。脚本只能执行一次，第二次需要重启。另外同一个DNS不能被同时查询，把8.8.8.8改成你没有在用的DNS。这个脚本的一个“副作用”就是dig返回的答案是正确的了，因为错误的答案被丢弃了。&lt;/p&gt;

&lt;h3 id=&quot;反向观测&quot;&gt;反向观测&lt;/h3&gt;

&lt;p&gt;前面我们已经知道从国内请求国外的DNS服务器大体是怎么一个被劫持的过程了。接下来我们在国内搭建一个服务器，从国外往国内发请求，看看是不是可以观测到被劫持的现象。&lt;/p&gt;

&lt;p&gt;把路由器的WAN口的防火墙打开。配置本地的dnsmasq为使用非标准端口代理查询从而保证本地做dig查询的时候可以拿到正确的结果。然后在国外的服务器上执行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dig @国内路由器ip twitter.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到收到的答案是错误的。执行前面的路由跟踪代码，结果如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;=== 隐去 ===
=== 隐去 ===
=== 隐去 ===
115.160.187.13
213.248.76.73
219.158.33.181
219.158.29.129
219.158.19.165
* 219.158.96.225
* * * 219.158.101.233
END
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到不但有DNS劫持，而且DNS劫持发生在非常靠近国内路由器的位置。这也证实了论文中提出的观测结果。GFW并没有严格地部署在出国境前第一跳的位置，而是更加靠前。并且是双向的，至少DNS劫持是双向经过实验证实了。&lt;/p&gt;

&lt;h2 id=&quot;通过避免gfw重建请求反dns劫持&quot;&gt;通过避免GFW重建请求反DNS劫持&lt;/h2&gt;

&lt;h3 id=&quot;使用非标准端口&quot;&gt;使用非标准端口&lt;/h3&gt;

&lt;p&gt;这个实验就非常简单了。使用53之外的端口查询DNS，观测是否有错误答案被返回。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dig @208.67.222.222 -p 5353 twitter.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用的DNS服务器是OpenDNS，端口为5353端口。使用非标准端口的DNS服务器不多，并不是所有的DNS服务器都会提供非标准端口供查询。结果如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.9.1-P3 &amp;lt;&amp;lt;&amp;gt;&amp;gt; @208.67.222.222 -p 5353 twitter.com
; (1 server found)
;; global options: +cmd
;; Got answer:
;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 5367
;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1    

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 8192
;; QUESTION SECTION:
;twitter.com.                        IN        A    

;; ANSWER SECTION:
twitter.com.                5        IN        A        199.59.150.39
twitter.com.                5        IN        A        199.59.148.82
twitter.com.                5        IN        A        199.59.148.10    

;; Query time: 194 msec
;; SERVER: 208.67.222.222#5353(208.67.222.222)
;; WHEN: Mon Jan 14 11:47:46 2013
;; MSG SIZE  rcvd: 88
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可见，非标准端口还是可以得到正确结果的。但是这种穿墙并不能被应用程序直接使用，因为几乎所有的应用程序都不支持使用非标准端口查询。有很多种办法把端口变成53端口能用。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用本地DNS服务器转发（dnsmasq，pdnsd）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用NetfilterQueue改写IP包&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用iptables改写IP包：&lt;code class=&quot;highlighter-rouge&quot;&gt;iptables -t nat -I OUTPUT --dst 208.67.222.222 -p udp --dport 53 -j DNAT --to-destination 208.67.222.222:5353&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;使用tcp查询&quot;&gt;使用TCP查询&lt;/h3&gt;

&lt;p&gt;这个实验就更加简单了，也是一条命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dig +tcp @8.8.8.8 twitter.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;GFW在日常是不屏蔽TCP的DNS查询的，所以可以得到正确的结果。但是和非标准端口一样，几乎所有的应用程序都不支持使用TCP查询。已知的TCP转UDP方式是使用pdnsd或者unbound转（http://otnth.blogspot.jp/2012/05/openwrt-dns.html?m=1）。&lt;/p&gt;

&lt;p&gt;但是GFW现在不屏蔽TCP的DNS查询并不代表GFW不能这么干。做一个小实验：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@OpenWrt:~# dig +tcp @8.8.8.8 dl.dropbox.com
;; communications error to 8.8.8.8#53: connection reset
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到GFW是能够知道你在查询什么的。与HTTP关键字过滤一样，一旦发现查询的内容不恰当，立马就发RST包过来切断连接。那么为什么GFW不审查所有的TCP的DNS查询呢？原因很简单，用TCP查询的绝对少数，尚不值得这么去干。而且就算你能查询到正确域名，GFW自认为还有HTTP关键字过滤和封IP等后着守着呢，犯不着在DNS上卡这么死。&lt;/p&gt;

&lt;h3 id=&quot;使用单向代理&quot;&gt;使用单向代理&lt;/h3&gt;

&lt;p&gt;严格来说单向代理并不是穿墙，因为它仍然需要在国外有一个代理服务器。使用代理服务器把DNS查询发出去，但是DNS查询并不经由代理服务器而是直接发回客户端。这样的实现在目前有更好的反劫持的手段（比如非标准端口）的情况下并不是一个有实际意义的做法。但是对于观测GFW的封锁机制还是有帮助的。据报道在敏感时期，对DNS不仅仅是劫持，而是直接丢包。通过单向代理可以观测丢包是针对出境流量的还是入境流量的。&lt;/p&gt;

&lt;p&gt;客户端需要使用iptables把DNS请求转给NetfilterQueue，然后用python代码把DNS请求包装之后发给中转代理。对于应用程序来说，这个包装的过程是透明的，它仍然认为请求是直接发给DNS服务器的。&lt;/p&gt;

&lt;p&gt;客户端代码如下，名字叫smuggler.py（&lt;a href=&quot;https://gist.github.com/4531012&quot;&gt;https://gist.github.com/4531012&lt;/a&gt;）：&lt;/p&gt;

&lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;


1




2




3




4




5




6




7




8




9




10




11




12




13




14




15




16




17




18




19




20




21




22




23




24




25




26




27




28




29




30




31




32




33




34




35

&lt;/td&gt;

&lt;td&gt;





`from` `netfilterqueue ``import` `NetfilterQueue`




`import` `subprocess`




`import` `signal`




`import` `traceback`




`import` `socket    `







`IMPERSONATOR_IP ``=` `'x.x.x.x'`




`IMPERSONATOR_PORT ``=` `19840`







`udp_socket ``=` `socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)    `







`def` `smuggle_packet(nfqueue_element):`




`   ``try``:`




`       ``original_packet ``=` `nfqueue_element.get_payload()`




`       ``print``(``'smuggled'``)`




`       ``udp_socket.sendto(original_packet, (IMPERSONATOR_IP, IMPERSONATOR_PORT))`




`       ``nfqueue_element.drop()`




`   ``except``:`




`       ``traceback.print_exc()`




`       ``nfqueue_element.accept()    `







`nfqueue ``=` `NetfilterQueue()`




`nfqueue.bind(``0``, smuggle_packet)    `







`def` `clean_up(``*``args):`




`   ``subprocess.call(``'iptables -D OUTPUT -p udp --dst 8.8.8.8 --dport 53 -j QUEUE'``, shell``=``True``)    `







`signal.signal(signal.SIGINT, clean_up)    `







`try``:`




`   ``subprocess.call(``'iptables -I OUTPUT -p udp --dst 8.8.8.8 --dport 53 -j QUEUE'``, shell``=``True``)`




`   ``print``(``'running..'``)`




`   ``nfqueue.run()`




`except` `KeyboardInterrupt:`




`   ``print``(``'bye'``)`




&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;服务器端代码如下，名字叫impersonator.py：&lt;/p&gt;

&lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;


1




2




3




4




5




6




7




8




9




10




11




12




13




14




15




16




17




18




19




20




21




22

&lt;/td&gt;

&lt;td&gt;





`import` `socket`




`import` `dpkt.ip    `







`def` `main_loop(server_socket, raw_socket):`




`    ``while` `True``:`




`        ``packet_bytes, from_ip ``=` `server_socket.recvfrom(``4096``)`




`        ``packet ``=` `dpkt.ip.IP(packet_bytes)`




`        ``dst ``=` `socket.inet_ntoa(packet.dst)`




`        ``print``(``'%s:%s =&amp;gt; %s:%s'` `%` `(socket.inet_ntoa(packet.src), packet.data.sport, dst, packet.data.dport))`




`        ``raw_socket.sendto(packet_bytes, (dst, ``0``))    `







`server_socket ``=` `socket.socket(socket.AF_INET, socket.SOCK_DGRAM)`




`try``:`




`    ``server_socket.bind((``'0.0.0.0'``, ``19840``))`




`    ``raw_socket ``=` `socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_RAW)`




`    ``try``:`




`        ``raw_socket.setsockopt(socket.SOL_IP, socket.IP_HDRINCL, ``1``)`




`        ``main_loop(server_socket, raw_socket)`




`    ``finally``:`




`        ``raw_socket.close()`




`finally``:`




`    ``server_socket.close()`




&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;在路由器上运行的时候要把WAN的防火墙规则改为接受INPUT，否则进入的UDP包会因为没有对应的出去的UDP包而被过滤掉。这是单向代理的一个缺陷，需要在墙上开洞。把防火墙整个打开是一种开洞的极端方式。后面专门讨论单向代理的时候会有更多关于防火墙凿洞的讨论。&lt;/p&gt;

&lt;p&gt;第二个运行的条件是服务器所在的网络没有对IP SPROOFING做过滤。服务器实际上使用了和GFW发错误答案一样的技术，就是伪造SRC地址。通过把SRC地址填成客户端所在的IP地址，使得DNS查询的结果不需要经过代理服务器中装直接到达客户端。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://static.wooyun.org//drops/20151117/2015111702571412746.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;通过丢弃错误答案反dns劫持&quot;&gt;通过丢弃错误答案反DNS劫持&lt;/h2&gt;

&lt;h3 id=&quot;使用iptables过滤&quot;&gt;使用iptables过滤&lt;/h3&gt;

&lt;p&gt;前两种方式都是针对GFW的重建这一步。因为GFW没有在日常的时候监听所有UDP端口以及监听TCP流量，所以非标准端口或者TCP的DNS查询可以被放行。选择性丢包则针对的是GFW的应对措施。既然GFW发错误的答案回来，只要我们不认它给的答案，等正确的答案来就是了。有两篇相关文档&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://kouga.us/?p=642724&quot;&gt;使用ipfilter过滤GFW滴DNS污染&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://code.google.com/p/openwrt-gfw/wiki/AntiDNSPoisoning&quot;&gt;AntiDNSPoisoning&lt;/a&gt; （作者有更新： &lt;a href=&quot;https://github.com/hackgfw/openwrt-gfw&quot;&gt;https://github.com/hackgfw/openwrt-gfw&lt;/a&gt;）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;改写成python脚本是这样的（&lt;a href=&quot;https://gist.github.com/4530465&quot;&gt;https://gist.github.com/4530465&lt;/a&gt;），实现来自于&lt;a href=&quot;https://code.google.com/p/openwrt-gfw/wiki/AntiDNSPoisoning&quot;&gt;AntiDNSPoisoning&lt;/a&gt;：&lt;/p&gt;

&lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;


1




2




3




4




5




6




7




8




9




10




11




12




13




14




15




16




17




18




19




20




21




22




23




24




25




26




27




28




29




30




31




32




33




34




35




36




37




38




39




40




41




42




43




44




45




46




47




48




49




50




51




52




53




54

&lt;/td&gt;

&lt;td&gt;





`import` `sys`




`import` `subprocess    `







`# source http://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93`




`WRONG_ANSWERS ``=` `{`




`    ``'4.36.66.178'``,`




`    ``'8.7.198.45'``,`




`    ``'37.61.54.158'``,`




`    ``'46.82.174.68'``,`




`    ``'59.24.3.173'``,`




`    ``'64.33.88.161'``,`




`    ``'64.33.99.47'``,`




`    ``'64.66.163.251'``,`




`    ``'65.104.202.252'``,`




`    ``'65.160.219.113'``,`




`    ``'66.45.252.237'``,`




`    ``'72.14.205.99'``,`




`    ``'72.14.205.104'``,`




`    ``'78.16.49.15'``,`




`    ``'93.46.8.89'``,`




`    ``'128.121.126.139'``,`




`    ``'159.106.121.75'``,`




`    ``'169.132.13.103'``,`




`    ``'192.67.198.6'``,`




`    ``'202.106.1.2'``,`




`    ``'202.181.7.85'``,`




`    ``'203.161.230.171'``,`




`    ``'207.12.88.98'``,`




`    ``'208.56.31.43'``,`




`    ``'209.36.73.33'``,`




`    ``'209.145.54.50'``,`




`    ``'209.220.30.174'``,`




`    ``'211.94.66.147'``,`




`    ``'213.169.251.35'``,`




`    ``'216.221.188.182'``,`




`    ``'216.234.179.13'`




`}    `







`rules ``=` `[``'-p udp --sport 53 -m u32 --u32 &quot;4 &amp;amp; 0x1FFF = 0 &amp;amp;&amp;amp; 0 &amp;gt;&amp;gt; 22 &amp;amp; 0x3C @ 8 &amp;amp; 0x8000 = 0x8000 &amp;amp;&amp;amp; 0 &amp;gt;&amp;gt; 22 &amp;amp; 0x3C @ 14 = 0&quot; -j DROP'``]`




`for` `wrong_answer ``in` `WRONG_ANSWERS:`




`    ``hex_ip ``=` `' '``.join([``'%02x'` `%` `int``(s) ``for` `s ``in` `wrong_answer.split(``'.'``)])`




`    ``rules.append(``'-p udp --sport 53 -m string --algo bm --hex-string &quot;|%s|&quot; --from 60 --to 180  -j DROP'` `%` `hex_ip)    `







`try``:`




`    ``for` `rule ``in` `rules:`




`        ``print``(rule)`




`        ``subprocess.call(``'iptables -I INPUT %s'` `%` `rule, shell``=``True``)`




`    ``print``(``'running..'``)`




`    ``sys.stdin.readline()`




`except` `KeyboardInterrupt:`




`    ``print``(``'bye'``)`




`finally``:`




`    ``for` `rule ``in` `reversed``(rules):`




`        ``subprocess.call(``'iptables -D INPUT %s'` `%` `rule, shell``=``True``)`




&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;本地有了这些iptables规则之后就可以丢弃掉GFW发回来的错误答案，从而得到正确的解析结果。这个脚本用到了两个iptables模块一个是u32一个是string。这两个内核模块不是所有的linux机器都有的。比如大部分的Android手机都没有这两个内核模块。所以上面的脚本适合内核模块很容易安装的场景，比如你的ubuntu pc。因为linux的内核模块与内核版本（每次编译基本都不同）是一一对应的，所以不同的linux机器是无法共享同样的内核模块的。所以基于内核模块的方案天然地具有安装困难的缺陷。&lt;/p&gt;

&lt;h3 id=&quot;使用nfqueue过滤&quot;&gt;使用nfqueue过滤&lt;/h3&gt;

&lt;p&gt;对于没有办法自己安装或者编译内核模块的场景，比如最常见的Android手机，厂家不告诉你内核的具体版本以及编译参数，普通用户是没有办法重新编译linux内核的。对于这样的情况，iptables提供了nfqueue，我们可以把内核模块做的ip过滤的工作交给用户态（也就是普通的应用程序）来完成。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CLEAN_DNS = '8.8.8.8'    

RULES = []
for iface in network_interface.list_data_network_interfaces():
    # this rule make sure we always query from the &quot;CLEAN&quot; dns
    RULE_REDIRECT_TO_CLEAN_DNS = (
        {'target': 'DNAT', 'iface_out': iface, 'extra': 'udp dpt:53 to:%s:53' % CLEAN_DNS},
        ('nat', 'OUTPUT', '-o %s -p udp --dport 53 -j DNAT --to-destination %s:53' % (iface, CLEAN_DNS))
    )
    RULES.append(RULE_REDIRECT_TO_CLEAN_DNS)
    RULE_DROP_PACKET = (
        {'target': 'NFQUEUE', 'iface_in': iface, 'extra': 'udp spt:53 NFQUEUE num 1'},
        ('filter', 'INPUT', '-i %s -p udp --sport 53 -j NFQUEUE --queue-num 1' % iface)
    )
    RULES.append(RULE_DROP_PACKET)    

# source http://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93
WRONG_ANSWERS = {
    '4.36.66.178',
    '8.7.198.45',
    '37.61.54.158',
    '46.82.174.68',
    '59.24.3.173',
    '64.33.88.161',
    '64.33.99.47',
    '64.66.163.251',
    '65.104.202.252',
    '65.160.219.113',
    '66.45.252.237',
    '72.14.205.99',
    '72.14.205.104',
    '78.16.49.15',
    '93.46.8.89',
    '128.121.126.139',
    '159.106.121.75',
    '169.132.13.103',
    '192.67.198.6',
    '202.106.1.2',
    '202.181.7.85',
    '203.161.230.171',
    '203.98.7.65',
    '207.12.88.98',
    '208.56.31.43',
    '209.36.73.33',
    '209.145.54.50',
    '209.220.30.174',
    '211.94.66.147',
    '213.169.251.35',
    '216.221.188.182',
    '216.234.179.13',
    '243.185.187.39'
}    

def handle_nfqueue():
    try:
        nfqueue = NetfilterQueue()
        nfqueue.bind(1, handle_packet)
        nfqueue.run()
    except:
        LOGGER.exception('stopped handling nfqueue')
        dns_service_status.error = traceback.format_exc()    

def handle_packet(nfqueue_element):
    try:
        ip_packet = dpkt.ip.IP(nfqueue_element.get_payload())
        dns_packet = dpkt.dns.DNS(ip_packet.udp.data)
        if contains_wrong_answer(dns_packet):
        # after the fake packet dropped, the real answer can be accepted by the client
            LOGGER.debug('drop fake dns packet: %s' % repr(dns_packet))
            nfqueue_element.drop()
            return
        nfqueue_element.accept()
        dns_service_status.last_activity_at = time.time()
    except:
        LOGGER.exception('failed to handle packet')
        nfqueue_element.accept()    

def contains_wrong_answer(dns_packet):
    if dpkt.dns.DNS_A not in [question.type for question in dns_packet.qd]:
        return False # not answer to A question, might be PTR
    for answer in dns_packet.an:
        if dpkt.dns.DNS_A == answer.type:
            resolved_ip = socket.inet_ntoa(answer['rdata'])
            if resolved_ip in WRONG_ANSWERS:
                return True # to find wrong answer
            else:
                LOGGER.info('dns resolve: %s =&amp;gt; %s' % (dns_packet.qd[0].name, resolved_ip))
                return False # if the blacklist is incomplete, we will think it is right answer
    return True # to find empty answer
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其原理是一样的，过滤所有的DNS应答，如果发现是错误的答案就丢弃。因为是基于nfqueue的，所以只要linux内核支持nfqueue，而且iptables可以添加nfqueue的target，就可以使用以上方式来丢弃DNS错误答案。目前已经成功在主流的android手机上运行该程序，并获得正确的DNS解析结果。另外，上面的实现利用iptables的重定向能力，达到了更换本机dns服务器的目的。无论机器设置的dns服务器是什么，通过上面的iptables规则，统统给你重定向到干净的DNS（8.8.8.8）。&lt;/p&gt;

&lt;p&gt;自此DNS穿墙的讨论基本上就完成了。DNS劫持是所有GFW封锁手段中最薄弱的一环，有很多种方法都可以穿过。如果不想写代码，用V2EX DNS的非标准端口是最容易的部署方式。如果愿意部署代码，用nfqueue丢弃错误答案是最可靠通用的方式，不依赖于特定的服务器。fqdns集成了所有的克服DNS劫持的手段，其为fqrouter的组成部分之一： &lt;a href=&quot;https://github.com/fqrouter/fqdns&quot;&gt;https://github.com/fqrouter/fqdns&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;封ip观测&quot;&gt;封IP观测&lt;/h2&gt;

&lt;h3 id=&quot;观测twittercom&quot;&gt;观测twitter.com&lt;/h3&gt;

&lt;p&gt;首先使用dig获得twitter.com的ip地址：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@OpenWrt:~# dig +tcp @8.8.8.8 twitter.com    

; &amp;lt;&amp;lt;&amp;gt;&amp;gt; DiG 9.9.1-P3 &amp;lt;&amp;lt;&amp;gt;&amp;gt; +tcp @8.8.8.8 twitter.com
; (1 server found)
;; global options: +cmd
;; Got answer:
;; -&amp;gt;&amp;gt;HEADER&amp;lt;&amp;lt;- opcode: QUERY, status: NOERROR, id: 8015
;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1    

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 512
;; QUESTION SECTION:
;twitter.com.                        IN        A    

;; ANSWER SECTION:
twitter.com.                7        IN        A        199.59.149.230
twitter.com.                7        IN        A        199.59.150.39
twitter.com.                7        IN        A        199.59.150.7
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;根据前面的内容我们知道使用dns over tcp，大部分的域名解析都不会被干扰的。这里得到了三个ip地址。先来测试199.59.149.230&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@OpenWrt:~# traceroute 199.59.149.230 -n
traceroute to 199.59.149.230 (199.59.149.230), 30 hops max, 38 byte packets
 1  123.114.32.1  19.862 ms  4.267 ms  101.431 ms
 2  61.148.163.73  920.148 ms  5.108 ms  3.868 ms
 3  124.65.56.129  7.596 ms  7.742 ms  7.735 ms
 4  123.126.0.133  5.310 ms  7.745 ms  7.573 ms
 5  *  *  *
 6  *  *  *
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个结果是最常见的。在骨干路由器上，针对这个ip丢包了。这种封锁方式就是最传统的封IP方式，BGP路由扩散，现象就是针对上行流量的丢包。再来看199.59.150.39&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@OpenWrt:~# traceroute 199.59.150.39 -n
traceroute to 199.59.150.39 (199.59.150.39), 30 hops max, 38 byte packets
 1  123.114.32.1  14.046 ms  20.322 ms  19.918 ms
 2  61.148.163.229  7.461 ms  7.182 ms  7.540 ms
 3  124.65.56.157  4.491 ms  3.342 ms  7.260 ms
 4  123.126.0.93  6.715 ms  7.309 ms  7.438 ms
 5  219.158.4.126  5.326 ms  3.217 ms  3.596 ms
 6  219.158.98.10  3.508 ms  3.606 ms  4.198 ms
 7  219.158.33.254  140.965 ms  133.414 ms  136.979 ms
 8  129.250.4.107  132.847 ms  137.153 ms  134.207 ms
 9  61.213.145.166  253.193 ms  253.873 ms  258.719 ms
10  199.16.159.15  257.592 ms  258.963 ms  256.034 ms
11  199.16.159.55  267.503 ms  268.595 ms  267.590 ms
12  199.59.150.39  266.584 ms  259.277 ms  263.364 ms
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在我撰写的时候，这个ip还没有被封。但是根据经验，twitter.com享受了最高层次的GFW关怀，新的ip基本上最慢也是隔日被封的。不过通过这个traceroute可以看到219.158.4.126其实就是那个之前捣乱的服务器，包是在它手里被丢掉的（严格来说并不一定是219.158.4.126，因为ip包经过的路由对于不同的目标ip设置不同的端口都可能会不一样）。再来看199.59.150.7&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@OpenWrt:~# traceroute 199.59.150.7 -n
traceroute to 199.59.150.7 (199.59.150.7), 30 hops max, 38 byte packets
 1  123.114.32.1  11.379 ms  10.420 ms  23.008 ms
 2  61.148.163.229  6.102 ms  6.777 ms  7.373 ms
 3  61.148.153.61  5.638 ms  3.148 ms  3.235 ms
 4  123.126.0.9  3.473 ms  3.306 ms  3.216 ms
 5  219.158.4.198  2.839 ms !H  *  6.136 ms !H
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这次同样是封IP，但是现象不同。通过抓包可以观察到是什么问题：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@OpenWrt:~# tcpdump -i pppoe-wan host 199.59.150.7 or icmp -vvv
07:46:11.355913 IP (tos 0x0, ttl 251, id 0, offset 0, flags [none], proto ICMP (1), length 56)
    219.158.4.198 &amp;gt; 123.114.40.44: ICMP host r-199-59-150-7.twttr.com unreachable, length 36
        IP (tos 0x0, ttl 1, id 0, offset 0, flags [DF], proto UDP (17), length 38)
    123.114.40.44.45021 &amp;gt; r-199-59-150-7.twttr.com.33449: UDP, length 10
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;原来219.158.4.198发回来了一个ICMP包，内容是地址不可到达（unreachable）。于是traceroute就在那里断掉了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@OpenWrt:~# iptables -I INPUT -p icmp --icmp-type 3 -j DROP
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果把unreachable类型的ICMP包丢弃掉，会发现ip包仍然过不去&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@OpenWrt:~# traceroute 199.59.150.7 -n
traceroute to 199.59.150.7 (199.59.150.7), 30 hops max, 38 byte packets
 1  123.114.32.1  4.866 ms  3.165 ms  3.212 ms
 2  61.148.163.229  3.107 ms  3.104 ms  3.270 ms
 3  61.148.153.61  6.001 ms  7.246 ms  7.398 ms
 4  123.126.0.9  7.840 ms  7.223 ms  7.443 ms
 5  *  *  *
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这次就和被丢包了是一样的观测现象了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@OpenWrt:~# iptables -L -v -n | grep icmp
    3   168 DROP       icmp --  *      *       0.0.0.0/0            0.0.0.0/0           icmp type 3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;同时，可以看到我们仍然是收到了icmp地址不可到达的包的，只是被我们drop掉了。&lt;/p&gt;

&lt;h3 id=&quot;观测被封ip的反向流量&quot;&gt;观测被封ip的反向流量&lt;/h3&gt;

&lt;p&gt;之前的观测中，被封的ip是ip包的dst。如果我们从国外往国内发包，其src是被封的ip，那么ip包是否会被GFW过滤掉呢？登录到一台国外的vps上执行下面的python代码&lt;/p&gt;

&lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;


1




2

&lt;/td&gt;

&lt;td&gt;





`from` `scapy.``all` `import` `*`




`send(IP(src``=``&quot;199.59.150.7&quot;``, dst``=``&quot;123.114.40.44&quot;``)``/``ICMP())`




&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;然后在国内的路由器（123.114.40.44）上执行抓包程序&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@OpenWrt:~# tcpdump -i pppoe-wan host 199.59.150.7 or icmp -vvv
tcpdump: listening on pppoe-wan, link-type LINUX_SLL (Linux cooked), capture size 65535 bytes
10:41:14.294671 IP (tos 0x0, ttl 50, id 1, offset 0, flags [none], proto ICMP (1), length 28)
    r-199-59-150-7.twttr.com &amp;gt; 123.114.40.44: ICMP echo request, id 0, seq 0, length 8
10:41:14.294779 IP (tos 0x0, ttl 64, id 25013, offset 0, flags [none], proto ICMP (1), length 28)
    123.114.40.44 &amp;gt; r-199-59-150-7.twttr.com: ICMP echo reply, id 0, seq 0, length 8
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到，如果该ip是src而不是dst并不会被GFW过滤。这一行为有两种可能：要么GFW认为封dst就可以了，不屑于再封src了。另外一种可能是GFW封twitter的IP用的是路由表扩散技术，而传统的路由表是基于dst做路由判断的（高级的路由器可以根据src甚至端口号做为路由的依据），所以dst路由表导致的路由黑洞并不会影响该ip为src的情况。我相信是后者，但是GFW在封个人翻墙主机上所表现的实力（对大量的ip做精确到端口的全国性丢包）让我们相信，GFW很容易把封锁变成双向的。不过说实话，在这个硬实力的背后，靠的更多的是CISCO下一代骨干网路由器的超强处理能力，而不是GFW自身。&lt;/p&gt;

&lt;h3 id=&quot;单向代理&quot;&gt;单向代理&lt;/h3&gt;

&lt;p&gt;因为GFW对IP的封锁是针对上行流量的，所以使得单向代理就可以突破封锁。上行的IP包经过单向代理转发给目标服务器，下行的IP包直接由目标服务器发回给客户端。代码与DNS（UDP协议）的单向代理是一样的。因为单向代理利用的是IP协议，所以TCP与UDP都是一样的。除了单向代理，目前尚没有其他的办法穿过GFW访问被封的IP，只能使用传统的翻墙技术，SOCKS代理或者VPN这些。&lt;/p&gt;

&lt;p&gt;使用中国IP访问twitter一文中有更详细的描述：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://fqrouter.tumblr.com/post/38463337823/ip-twitter-1-nfqueue-packet&quot;&gt;http://fqrouter.tumblr.com/post/38463337823/ip-twitter-1-nfqueue-packet&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://fqrouter.tumblr.com/post/38465016969/ip-twitter-2-nat&quot;&gt;http://fqrouter.tumblr.com/post/38465016969/ip-twitter-2-nat&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://fqrouter.tumblr.com/post/38468377418/ip-twitter-3-raw-socket&quot;&gt;http://fqrouter.tumblr.com/post/38468377418/ip-twitter-3-raw-socket&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://fqrouter.tumblr.com/post/38469096940/ip-twitter-4&quot;&gt;http://fqrouter.tumblr.com/post/38469096940/ip-twitter-4&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有一个小工具来实现单向代理: &lt;a href=&quot;https://github.com/fqrouter/fquni&quot;&gt;https://github.com/fqrouter/fquni&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 19 Nov 2015 10:47:08 +0800</pubDate>
        <link>http://localhost:4000/blog/2015/11/19/e7-bf-bb-e5-a2-99-e8-b7-af-e7-94-b1-e5-99-a8-e7-9a-84-e5-8e-9f-e7-90-86-e4-b8-8e-e5-ae-9e-e7-8e-b0/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2015/11/19/e7-bf-bb-e5-a2-99-e8-b7-af-e7-94-b1-e5-99-a8-e7-9a-84-e5-8e-9f-e7-90-86-e4-b8-8e-e5-ae-9e-e7-8e-b0/</guid>
        
        
        <category>技术文章</category>
        
      </item>
    
      <item>
        <title>分布式存储</title>
        <description>&lt;p&gt;分布存储方案&lt;/p&gt;

&lt;p&gt;一.BitCask&lt;/p&gt;

&lt;p&gt;这篇文章很好(http://blog.csdn.net/qq910894904/article/details/37756377)&lt;/p&gt;

&lt;h2 id=&quot;1存储的介质与读写&quot;&gt;1.存储的介质与读写&lt;/h2&gt;

&lt;p&gt;谈存储，那么理解存储的介质的特性显然很重要，书中谈了很多硬件结构，但最重要的结论，都浓缩在存储介质对比这张表中了。&lt;/p&gt;

&lt;p&gt;磁盘介质对比&lt;/p&gt;
&lt;table&gt;

&lt;tr&gt;
类别
每秒读写(IOPS)次数
每GB价格(元)
随机读取
随机写入
&lt;/tr&gt;

&lt;tbody&gt;
&lt;tr&gt;

&lt;td&gt;内存
&lt;/td&gt;

&lt;td&gt;千万级
&lt;/td&gt;

&lt;td&gt;150
&lt;/td&gt;

&lt;td&gt;友好
&lt;/td&gt;

&lt;td&gt;友好
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;

&lt;td&gt;SSD盘
&lt;/td&gt;

&lt;td&gt;35000
&lt;/td&gt;

&lt;td&gt;20
&lt;/td&gt;

&lt;td&gt;友好
&lt;/td&gt;

&lt;td&gt;写入放大问题
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;

&lt;td&gt;SAS磁盘
&lt;/td&gt;

&lt;td&gt;180
&lt;/td&gt;

&lt;td&gt;3
&lt;/td&gt;

&lt;td&gt;磁盘寻道
&lt;/td&gt;

&lt;td&gt;磁盘寻道
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;

&lt;td&gt;SATA磁盘
&lt;/td&gt;

&lt;td&gt;90
&lt;/td&gt;

&lt;td&gt;0.5
&lt;/td&gt;

&lt;td&gt;磁盘寻道
&lt;/td&gt;

&lt;td&gt;磁盘寻道
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;从表中可以看出，内存的随机读写能力最强，远超SSD盘和磁盘。但是我们都知道，内存无法持久化。现在许多公司在性能要求高的地方都使用了SSD盘，相对SAS和SATA磁盘，随机读取速度有了很大的提升。但是对于随机写入，存在写入放大问题。&lt;/p&gt;

&lt;blockquote&gt;写入放大问题与SSD盘的特性有关，SSD盘不能随机写入，只能整块整块的写入。最简单的例子，比如要写入一个4KB的数据，最坏的情况就是，一个块里已经没有干净空间了，但是有无效数据可以擦除，所以主控就把所有的数据读出来，擦除块，再加上这个4KB新数据写回去，这个操作带来的写入放大就是: 实际写4K的数据，造成了整个块（512KB）的写入操作，那就是128倍放大。此外，SSD盘的寿命也有写入次数相关。&lt;/blockquote&gt;

&lt;p&gt;如果使用SSD来作为存储引擎的存储介质，最好从设计上减少或避免随机写入，使用顺序写入取而代之。&lt;/p&gt;

&lt;h2 id=&quot;2bitcask存储模型介绍&quot;&gt;2.Bitcask存储模型介绍&lt;/h2&gt;

&lt;blockquote&gt;存储系统的基本功能包括：增、删、读、改。其中读取操作有分为顺序读取和随机读取。&lt;/blockquote&gt;

&lt;p&gt;总体来说，大部分应用使用读的功能最多，解决读的性能是存储系统的重要命题。一般来说。快速查找的思想基本源自二分查找法和哈希查询。例如关系数据库中常用的B+存储模型就是使用二分查找的思想，当然，实际实现比二分查找复杂很多。B+存储模型支持顺序扫描。另外一类则是基于哈希思想的键值模型，这类模型不支持顺序扫描，仅支持随机读取。&lt;/p&gt;

&lt;p&gt;今天要讨论的Bitcask模型是一种日志型键值模型。所谓日志型，是指它不直接支持随机写入，而是像日志一样支持追加操作。Bitcask模型将随机写入转化为顺序写入。有两个好处：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;提高随机写入的吞吐量，因为写操作不需要查找，直接追加即可&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果使用SSD作为存储介质，能够更好的利用新硬件的特性&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Bitcask中存在3种文件，包括数据文件,索引文件和线索文件(hint file,姑且就叫线索文件吧)。数据文件存储于磁盘上，包含了原始的数据的键值信息；索引文件存在于内存，用于记录记录的位置信息，启动Bitcask时，它会将所有数据的位置信息全部读入一个内存中的哈希表，也就是索引文件；线索文件(hint file)并不是Bitcask的必需文件，它的存在是为了提供启动时构建索引文件的速度。&lt;/p&gt;

&lt;h3 id=&quot;21-日志型的数据文件&quot;&gt;2.1 日志型的数据文件&lt;/h3&gt;

&lt;p&gt;Bitcask的数据文件组织如下图：任意时刻，系统中只有一个数据文件支持写入，称为active data file。其余的数据文件都是只读文件，称为older data file。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20140714210527939?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXE5MTA4OTQ5MDQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;文件中的数据结构非常简单，是一条一条的数据写入操作，每一条数据的结构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20140714210603304&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面数据项分别为：后面几项的crc校验值,时间戳,key，value，key的大小，value的大小。
数据文件中就是连续一条条上面格式的数据，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20140714210627718&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;22-索引哈希表&quot;&gt;2.2 索引哈希表&lt;/h3&gt;

&lt;p&gt;索引哈希表记录了全部记录的主键和位置信息，索引哈希表的值包含了：记录文件的编号,value长度,value的在文件中的位置和时间戳。Bitcask的总体数据结构如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20140714210409812&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;23-线索文件hint-file&quot;&gt;2.3 线索文件(hint file)&lt;/h3&gt;

&lt;p&gt;Bitcask启动时要重建索引哈希表，如果数据量特别大，则会导致启动很慢。而线索文件(hint file)则是用来加速启动时重建哈希表的速度。线索文件(hint file)的记录与数据文件的格式基本相同，唯一不同的是数据文件记录数据的值，而线索文件(hint file)则是记录数据的位置。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20140714210424828&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这样在启动的时候就可以不用读数据文件，而是读取线索文件(hint file)，一行行重建即可，大大加快了哈希表的重建速度。&lt;/p&gt;

&lt;h2 id=&quot;3-bitcask功能介绍&quot;&gt;3. Bitcask功能介绍&lt;/h2&gt;

&lt;p&gt;上节提到，存储系统的基本功能包括：增、删、读、改。那么Bitcask中如何实现的呢？&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;如何增加记录？
用户写入的记录直接追加到活动文件，因此活动文件会越来越大，当到达一定大小时，Bitcask会冻结活动文件，新建一个活动文件用于写入，而之前的活动文件则变为了older data file。写入记录的同时还要在索引哈希表中添加索引记录。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如何删除记录？
Bitcask不直接删除记录，而是新增一条相同key的记录，把value值设置一个删除的标记。原有记录依然存在于数据文件中，然后更新索引哈希表。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如何修改记录？
Bitcask不支持随机写入。因为对于存储系统的基本功能中的增和改，实际上都是一样的，都是直接写入活动数据文件。同时修改索引哈希表中对应记录的值。(这个时候，实际上数据文件中同一个key值对应了多条记录，根据时间戳记录来判断，以最新的数据为准。)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如何读取记录?
读取时，首先从索引哈希表中定位到记录在磁盘中位置，然后通过IO读取出对应的记录。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;合并(Marge)操作
Bitcask这种只增不减地不断写入，必然会是数据文件不断的膨胀。而其中有许多是被标记删除和修改后留下的无用记录。合并操作就是为了剔除这部分数据，减小数据文件大小。
merge操作，通过定期将所有older data file中的数据扫描一遍并生成新的data file（没有包括active data file 是因为它还在不停写入）。如果同一个Key有多条记录，则只保留最新的一条。从而去掉数据文件中的冗余数据。而且进行合并(Marge)操作时，还可以顺带生成线索文件(hint file)。合并(Marge)操作通常会在数据库较闲的时候进行，比如凌晨一两点等。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;二、关系连数据结构的设计&lt;/p&gt;

&lt;p&gt;1，key-list&lt;/p&gt;

&lt;p&gt;2，key-table&lt;/p&gt;

&lt;p&gt;3，redis 有序集&lt;/p&gt;

&lt;p&gt;4, netMq,httpsqs,activeMq&lt;/p&gt;

&lt;p&gt;各人使用过redis有序集，使用起来方便，但是造价高是个问题，在排名设计文章时，详细说明过，其他数据结构详细补充&lt;/p&gt;

&lt;p&gt;三、ZooKeeper 名字服务做分布式服务器群组&lt;/p&gt;

&lt;p&gt;记录&lt;/p&gt;
</description>
        <pubDate>Thu, 24 Sep 2015 16:31:02 +0800</pubDate>
        <link>http://localhost:4000/blog/2015/09/24/e5-88-86-e5-b8-83-e5-bc-8f-e5-ad-98-e5-82-a8/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2015/09/24/e5-88-86-e5-b8-83-e5-bc-8f-e5-ad-98-e5-82-a8/</guid>
        
        
        <category>技术文章</category>
        
      </item>
    
      <item>
        <title>php json_decode返回NULL 特别是使用file_get_contents</title>
        <description>&lt;p&gt;今天遇到了json_decode无法解析json的情况，很是头痛，查来查去原来 编码服务器可以正常解析，但是解码服务无法解析，等到把整个json字串 放到页面上查看元素突然发现json字串头部多了字串，考虑是BOM问题，然后在编码服务打印字串长度6617到了解码服务打印长度成了6620 还要多一点，因些断定是BOM引起的json_decode无法解析。&lt;/p&gt;

&lt;p&gt;if(preg_match(‘/^\xEF\xBB\xBF/’,$receive_part))
{
$receive_part= substr($receive_part,3);
}&lt;/p&gt;

&lt;p&gt;去掉BOM 解析正常,原来形成应该是编码服务使用header(‘Content-Type:application/json; charset=utf-8’);转UTF－8时形成的BOM 。&lt;/p&gt;
</description>
        <pubDate>Thu, 20 Aug 2015 20:55:28 +0800</pubDate>
        <link>http://localhost:4000/blog/2015/08/20/php-json_decode-e8-bf-94-e5-9b-9enull-e7-89-b9-e5-88-ab-e6-98-af-e4-bd-bf-e7-94-a8file_get_contents/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2015/08/20/php-json_decode-e8-bf-94-e5-9b-9enull-e7-89-b9-e5-88-ab-e6-98-af-e4-bd-bf-e7-94-a8file_get_contents/</guid>
        
        
        <category>技术文章</category>
        
      </item>
    
      <item>
        <title>测试hhvm 与phpfpm性能</title>
        <description>&lt;p&gt;总是说hhvm性能很高亲测试数据如下：&lt;/p&gt;

&lt;p&gt;从cpu\mem\io 三个方面&lt;/p&gt;

&lt;p&gt;服务器：&lt;/p&gt;

&lt;p&gt;cpu 8核 3.30GHz&lt;/p&gt;

&lt;p&gt;mem 16G&lt;/p&gt;

&lt;p&gt;disk 500G&lt;/p&gt;

&lt;p&gt;一、time 测试：&lt;/p&gt;

&lt;p&gt;网上的例子CUP&lt;/p&gt;

&lt;p&gt;test.php&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php
function fib($n)
{
    if ($n &amp;lt;= 2)
        return 1;
    else
        return fib($n-1) + fib($n-2);
}

$n = 36;
printf(&quot;fib(%d) = %d\n&quot;, $n, fib($n, 2));
?&amp;gt;
root#time hhvm test.php
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;real 0m0.407s
user 0m0.336s
sys 0m0.068s&lt;/p&gt;

&lt;p&gt;root #time php test.php&lt;/p&gt;

&lt;p&gt;real 0m1.046s
user 0m0.952s
sys 0m0.092s&lt;/p&gt;

&lt;p&gt;内存及IO 也相差类似&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;二、ab测试
ab -c1000 -n500 http://xxx.xxx.com/test.php
分别在hhvm php-fpm下
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;php-fpm:数据：&lt;/p&gt;

&lt;p&gt;Server Port: 80&lt;/p&gt;

&lt;p&gt;Document Path: /test.php
Document Length: 0 bytes&lt;/p&gt;

&lt;p&gt;Concurrency Level: 500
Time taken for tests: 40.838 seconds
Complete requests: 1000
Failed requests: 0
Write errors: 0
Total transferred: 159000 bytes
HTML transferred: 0 bytes
Requests per second: 24.49 [#/sec] (mean)
Time per request: 20419.000 [ms] (mean)
Time per request: 40.838 [ms] (mean, across all concurrent reque
Transfer rate: 3.80 [Kbytes/sec] received&lt;/p&gt;

&lt;p&gt;Connection Times (ms)
min mean[+/-sd] median max
Connect: 40 41 0.5 41 43
Processing: 52 15287 6568.0 20288 20420
Waiting: 52 10177 5887.2 10185 20417
Total: 92 15328 6567.9 20328 20461&lt;/p&gt;

&lt;p&gt;hhvm:&lt;/p&gt;

&lt;p&gt;Document Path: /test.php
Document Length: 0 bytes&lt;/p&gt;

&lt;p&gt;Concurrency Level: 500
Time taken for tests: 40.834 seconds
Complete requests: 1000
Failed requests: 0
Write errors: 0
Total transferred: 197000 bytes
HTML transferred: 0 bytes
Requests per second: 24.49 [#/sec] (mean)
Time per request: 20417.000 [ms] (mean)
Time per request: 40.834 [ms] (mean, across all concurrent reques
Transfer rate: 4.71 [Kbytes/sec] received&lt;/p&gt;

&lt;p&gt;Connection Times (ms)
min mean[+/-sd] median max
Connect: 40 41 0.5 41 42
Processing: 44 15287 6567.5 20297 20414
Waiting: 44 10199 5887.7 10216 20409
Total: 85 15328 6567.4 20338 20454&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;经测试qps相差不多，基本一样（很是奇怪）但是 HHVM在c1000 n1000时，确实抗住了，但是php-fpm在同环境下，机器死掉

再看负载：
php-fpm
load average: 0.22, 0.08, 0.03
hhvm




load average: 0.12, 0.08, 0.03

总体来看 hhvm性能是优于fpm的
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 12 Jun 2015 16:01:23 +0800</pubDate>
        <link>http://localhost:4000/blog/2015/06/12/e6-b5-8b-e8-af-95hhvm-e4-b8-8ephpfpm-e6-80-a7-e8-83-bd/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2015/06/12/e6-b5-8b-e8-af-95hhvm-e4-b8-8ephpfpm-e6-80-a7-e8-83-bd/</guid>
        
        
        <category>技术文章</category>
        
      </item>
    
      <item>
        <title>mysql 配置优化</title>
        <description>&lt;p&gt;**感觉这篇文章比较靠谱 收藏，经常会说优化 ，基本从三个方面，配置优化、设计优化、使用优化。这个文章从配置 方面来说不错
**&lt;/p&gt;

&lt;p&gt;转自：http://www.itokit.com/2013/0412/74892.html&lt;/p&gt;

&lt;p&gt;定运行了一段时间后运行，根据服务器的“状态”进行优化。
mysql&amp;gt; show global status;
可以列出MySQL服务器运行各种状态值，我个人较喜欢的用法是show status like ‘查询值%’;
一、慢查询
mysql&amp;gt; show variables like ‘%slow%’;
+——————+——-+
| Variable_name | Value |
+——————+——-+
| log_slow_queries | ON |
| slow_launch_time | 2     |
+——————+——-+
mysql&amp;gt; show global status like ‘%slow%’;
+———————+——-+
| Variable_name    | Value |
+———————+——-+
| Slow_launch_threads | 0     |
| Slow_queries        | 4148 |
+———————+——-+
打开慢查询日志可能会对系统性能有一点点影响，如果你的MySQL是主－从结构，可以考虑打开其中一台从服务器的慢查询日志，这样既可以监控慢查询，对系统性能影响又小，另mysql有自带的命令mysqldumpslow可进行查询，例下列命令可以查出访问次数最多的20个sql语句mysqldumpslow -s c -t 20 host-slow.log&lt;/p&gt;

&lt;p&gt;二、连接数
经常会遇见”MySQL: ERROR 1040: Too manyconnections”的情况，一种是访问量确实很高，MySQL服务器抗不住，这个时候就要考虑增加从服务器分散读压力，另外一种情况是MySQL配置文件中max_connections值过小：
mysql&amp;gt; show variables like ‘max_connections’;
+—————–+——-+
| Variable_name | Value |
+—————–+——-+
| max_connections | 256 |
+—————–+——-+
这台MySQL服务器最大连接数是256，然后查询一下服务器响应的最大连接数：
mysql&amp;gt; show global status like ‘Max_used_connections’;
+———————-+——-+
| Variable_name        | Value |
+———————-+——-+
| Max_used_connections | 245 |
+———————-+——-+
MySQL服务器过去的最大连接数是245，没有达到服务器连接数上限256，应该没有出现1040错误，比较理想的设置是：
Max_used_connections / max_connections   * 100% ≈ 85%
最大连接数占上限连接数的85％左右，如果发现比例在10%以下，MySQL服务器连接数上限设置的过高了。&lt;/p&gt;

&lt;p&gt;三、Key_buffer_size
key_buffer_size是对MyISAM表性能影响最大的一个参数，下面一台以MyISAM为主要存储引擎服务器的配置：
mysql&amp;gt; show variables like ‘key_buffer_size’;
+—————–+————+
| Variable_name | Value    |
+—————–+————+
| key_buffer_size | 536870912 |
+—————–+————+
分配了512MB内存给key_buffer_size，我们再看一下key_buffer_size的使用情况：
mysql&amp;gt; show global status like ‘key_read%’;
+————————+————-+
| Variable_name       | Value    |
+————————+————-+
| Key_read_requests    | 27813678764 |
| Key_reads              | 6798830     |
+————————+————-+
一共有27813678764个索引读取请求，有6798830个请求在内存中没有找到直接从硬盘读取索引，计算索引未命中缓存的概率：
key_cache_miss_rate ＝ Key_reads / Key_read_requests * 100%
比如上面的数据，key_cache_miss_rate为0.0244%，4000个索引读取请求才有一个直接读硬盘，已经很BT 了，key_cache_miss_rate在0.1%以下都很好（每1000个请求有一个直接读硬盘），如果key_cache_miss_rate在 0.01%以下的话，key_buffer_size分配的过多，可以适当减少。
MySQL服务器还提供了key_blocks_*参数：
mysql&amp;gt; show global status like ‘key_blocks_u%’;
+————————+————-+
| Variable_name       | Value    |
+————————+————-+
| Key_blocks_unused    | 0           |
| Key_blocks_used        | 413543    |
+————————+————-+
Key_blocks_unused 表示未使用的缓存簇(blocks)数，Key_blocks_used表示曾经用到的最大的blocks数，比如这台服务器，所有的缓存都用到了，要么 增加key_buffer_size，要么就是过渡索引了，把缓存占满了。比较理想的设置：Key_blocks_used / (Key_blocks_unused + Key_blocks_used) * 100% ≈ 80%
四、临时表
mysql&amp;gt; show global status like ‘created_tmp%’;
+————————-+———+
| Variable_name           | Value |
+————————-+———+
| Created_tmp_disk_tables | 21197 |
| Created_tmp_files    | 58    |
| Created_tmp_tables    | 1771587 |
+————————-+———+
每次创建临时表，Created_tmp_tables增加，如果是在磁盘上创建临时表，Created_tmp_disk_tables也增加,Created_tmp_files表示MySQL服务创建的临时文件文件数，比较理想的配置是：
Created_tmp_disk_tables / Created_tmp_tables * 100% &amp;lt;= 25%
比如上面的服务器Created_tmp_disk_tables / Created_tmp_tables * 100% ＝ 1.20%，应该相当好了。我们再看一下MySQL服务器对临时表的配置：
mysql&amp;gt; show variables where Variable_name in (‘tmp_table_size’, ‘max_heap_table_size’);
+———————+———–+
| Variable_name    | Value     |
+———————+———–+
| max_heap_table_size | 268435456 |
| tmp_table_size    | 536870912 |
+———————+———–+
只有256MB以下的临时表才能全部放内存，超过的就会用到硬盘临时表。&lt;/p&gt;

&lt;p&gt;五、Open Table情况
mysql&amp;gt; show global status like ‘open%tables%’;
+—————+——-+
| Variable_name | Value |
+—————+——-+
| Open_tables | 919 |
| Opened_tables | 1951   |
+—————+——-+
Open_tables 表示打开表的数量，Opened_tables表示打开过的表数量，如果Opened_tables数量过大，说明配置中 table_cache(5.1.3之后这个值叫做table_open_cache)值可能太小，我们查询一下服务器table_cache值：
mysql&amp;gt; show variables like ‘table_cache’;
+—————+——-+
| Variable_name | Value |
+—————+——-+
| table_cache | 2048   |&lt;/p&gt;

&lt;p&gt;+—————+——-+
比较合适的值为：
Open_tables / Opened_tables   * 100% &amp;gt;= 85%
Open_tables / table_cache * 100% &amp;lt;= 95%&lt;/p&gt;

&lt;p&gt;六、进程使用情况
mysql&amp;gt; show global status like ‘Thread%’;
+——————-+——-+
| Variable_name     | Value |
+——————-+——-+
| Threads_cached | 46 |
| Threads_connected | 2     |
| Threads_created | 570 |
| Threads_running | 1     |
+——————-+——-+
如果我们在MySQL服务器配置文件中设置了thread_cache_size，当客户端断开之后，服务器处理此客户的线程将会缓存起来以响应下一个客户 而不是销毁（前提是缓存数未达上限）。Threads_created表示创建过的线程数，如果发现Threads_created值过大的话，表明 MySQL服务器一直在创建线程，这也是比较耗资源，可以适当增加配置文件中thread_cache_size值，查询服务器 thread_cache_size配置：
mysql&amp;gt; show variables like ‘thread_cache_size’;
+——————-+——-+
| Variable_name     | Value |
+——————-+——-+
| thread_cache_size | 64 |
+——————-+——-+
示例中的服务器还是挺健康的。&lt;/p&gt;

&lt;p&gt;七、查询缓存(query cache)
mysql&amp;gt; show global status like ‘qcache%’;
+————————-+———–+
| Variable_name           | Value     |
+————————-+———–+
| Qcache_free_blocks    | 22756     |
| Qcache_free_memory    | 76764704   |
| Qcache_hits          | 213028692 |
| Qcache_inserts       | 208894227 |
| Qcache_lowmem_prunes | 4010916 |
| Qcache_not_cached    | 13385031   |
| Qcache_queries_in_cache | 43560     |
| Qcache_total_blocks     | 111212 |
+————————-+———–+
MySQL查询缓存变量解释：
Qcache_free_blocks：缓存中相邻内存块的个数。数目大说明可能有碎片。FLUSH QUERY CACHE会对缓存中的碎片进行整理，从而得到一个空闲块。
Qcache_free_memory：缓存中的空闲内存。
Qcache_hits：每次查询在缓存中命中时就增大
Qcache_inserts：每次插入一个查询时就增大。命中次数除以插入次数就是不中比率。
Qcache_lowmem_prunes： 缓存出现内存不足并且必须要进行清理以便为更多查询提供空间的次数。这个数字最好长时间来看；如果这个数字在不断增长，就表示可能碎片非常严重，或者内存 很少。（上面的 free_blocks和free_memory可以告诉您属于哪种情况）
Qcache_not_cached：不适合进行缓存的查询的数量，通常是由于这些查询不是 SELECT 语句或者用了now()之类的函数。
Qcache_queries_in_cache：当前缓存的查询（和响应）的数量。
Qcache_total_blocks：缓存中块的数量。&lt;/p&gt;

&lt;p&gt;我们再查询一下服务器关于query_cache的配置：
mysql&amp;gt; show variables like ‘query_cache%’;
+——————————+———–+
| Variable_name             | Value     |
+——————————+———–+
| query_cache_limit          | 2097152 |
| query_cache_min_res_unit     | 4096    |
| query_cache_size          | 203423744 |
| query_cache_type          | ON        |
| query_cache_wlock_invalidate | OFF    |
+——————————+———–+
各字段的解释：
query_cache_limit：超过此大小的查询将不缓存
query_cache_min_res_unit：缓存块的最小大小
query_cache_size：查询缓存大小
query_cache_type：缓存类型，决定缓存什么样的查询，示例中表示不缓存 select sql_no_cache 查询
query_cache_wlock_invalidate：当有其他客户端正在对MyISAM表进行写操作时，如果查询在query cache中，是否返回cache结果还是等写操作完成再读表获取结果。
query_cache_min_res_unit的配置是一柄”双刃剑”，默认是4KB，设置值大对大数据查询有好处，但如果你的查询都是小数据查询，就容易造成内存碎片和浪费。
查询缓存碎片率 = Qcache_free_blocks / Qcache_total_blocks * 100%
如果查询缓存碎片率超过20%，可以用FLUSH QUERY CACHE整理缓存碎片，或者试试减小query_cache_min_res_unit，如果你的查询都是小数据量的话。
查询缓存利用率 = (query_cache_size - Qcache_free_memory) / query_cache_size * 100%
查询缓存利用率在25%以下的话说明query_cache_size设置的过大，可适当减小；查询缓存利用率在80％以上而且Qcache_lowmem_prunes &amp;gt; 50的话说明query_cache_size可能有点小，要不就是碎片太多。
查询缓存命中率 = (Qcache_hits - Qcache_inserts) / Qcache_hits * 100%
示例服务器 查询缓存碎片率 ＝ 20.46％，查询缓存利用率 ＝ 62.26％，查询缓存命中率 ＝ 1.94％，命中率很差，可能写操作比较频繁吧，而且可能有些碎片。&lt;/p&gt;

&lt;p&gt;八、排序使用情况
mysql&amp;gt; show global status like ‘sort%’;
+——————-+————+
| Variable_name     | Value    |
+——————-+————+
| Sort_merge_passes | 29       |
| Sort_range        | 37432840 |
| Sort_rows       | 9178691532 |
| Sort_scan       | 1860569 |
+——————-+————+
Sort_merge_passes 包括两步。MySQL 首先会尝试在内存中做排序，使用的内存大小由系统变量Sort_buffer_size 决定，如果它的大小不够把所有的记录都读到内存中，MySQL 就会把每次在内存中排序的结果存到临时文件中，等MySQL 找到所有记录之后，再把临时文件中的记录做一次排序。这再次排序就会增加 Sort_merge_passes。实际上，MySQL会用另一个临时文件来存再次排序的结果，所以通常会看到 Sort_merge_passes增加的数值是建临时文件数的两倍。因为用到了临时文件，所以速度可能会比较慢，增加 Sort_buffer_size 会减少Sort_merge_passes 和 创建临时文件的次数，但盲目的增加Sort_buffer_size 并不一定能提高速度&lt;/p&gt;

&lt;p&gt;九、文件打开数(open_files)
mysql&amp;gt; show global status like ‘open_files’;
+—————+——-+
| Variable_name | Value |
+—————+——-+
| Open_files | 1410   |
+—————+——-+
mysql&amp;gt; show variables like ‘open_files_limit’;
+——————+——-+
| Variable_name | Value |
+——————+——-+
| open_files_limit | 4590   |
+——————+——-+
比较合适的设置：Open_files / open_files_limit * 100% &amp;lt;= 75％&lt;/p&gt;

&lt;p&gt;十、表锁情况
mysql&amp;gt; show global status like ‘table_locks%’;
+———————–+———–+
| Variable_name       | Value     |
+———————–+———–+
| Table_locks_immediate | 490206328 |
| Table_locks_waited | 2084912 |
+———————–+———–+
Table_locks_immediate 表示立即释放表锁数，Table_locks_waited表示需要等待的表锁数，如果Table_locks_immediate / Table_locks_waited &amp;gt;5000，最好采用InnoDB引擎，因为InnoDB是行锁而MyISAM是表锁，对于高并发写入的应用InnoDB效果会好些。示例中的服务 器Table_locks_immediate / Table_locks_waited ＝ 235，MyISAM就足够了。&lt;/p&gt;

&lt;p&gt;十一、表扫描情况
mysql&amp;gt; show global status like ‘handler_read%’;
+———————–+————-+
| Variable_name       | Value    |
+———————–+————-+
| Handler_read_first | 5803750     |
| Handler_read_key    | 6049319850   |
| Handler_read_next     | 94440908210 |
| Handler_read_prev     | 34822001724 |
| Handler_read_rnd    | 405482605 |
| Handler_read_rnd_next | 18912877839 |
+———————–+————-+
mysql&amp;gt; show global status like ‘com_select’;
+—————+———–+
| Variable_name | Value     |
+—————+———–+
| Com_select | 222693559 |
+—————+———–+
计算表扫描率：
表扫描率 ＝ Handler_read_rnd_next / Com_select
如果表扫描率超过4000，说明进行了太多表扫描，很有可能索引没有建好，增加read_buffer_size值会有一些好处，但最好不要超过8MB。&lt;/p&gt;
</description>
        <pubDate>Wed, 13 May 2015 15:52:15 +0800</pubDate>
        <link>http://localhost:4000/blog/2015/05/13/mysql-e9-85-8d-e7-bd-ae-e4-bc-98-e5-8c-96/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2015/05/13/mysql-e9-85-8d-e7-bd-ae-e4-bc-98-e5-8c-96/</guid>
        
        <category>mysql</category>
        
        <category>优化</category>
        
        
        <category>技术文章</category>
        
      </item>
    
      <item>
        <title>PHP 资源大全 （转）</title>
        <description>&lt;p&gt;转自：http://blog.jobbole.com/82908/&lt;/p&gt;

&lt;p&gt;看到这篇文章不错，转来收藏&lt;/p&gt;

&lt;p&gt;依赖管理&lt;/p&gt;

&lt;p&gt;&lt;em&gt;依赖和包管理库&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://getcomposer.org/&quot;&gt;Composer&lt;/a&gt;/&lt;a href=&quot;http://packagist.org/&quot;&gt;Packagist&lt;/a&gt;：一个包和依赖管理器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/composer/installers&quot;&gt;Composer Installers&lt;/a&gt;：一个多框架Composer库安装器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/FriendsOfPHP/pickle&quot;&gt;Pickle&lt;/a&gt;：一个PHP扩展安装器&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;其他的依赖管理&quot;&gt;其他的依赖管理&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;其他的相关依赖管理&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/composer/satis&quot;&gt;Satis&lt;/a&gt;：一个静态Composer存储库生成器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/bamarni/composition&quot;&gt;Composition&lt;/a&gt;：一个在运行时检查Composer环境的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/herrera-io/php-version&quot;&gt;Version&lt;/a&gt;：语义版本的解析和比较库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ralphschindler/Namespacer&quot;&gt;NameSpacer&lt;/a&gt; -转化下划线到命名空间的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/goatherd/patch-installer&quot;&gt;Patch Installer&lt;/a&gt; -使用Composer安装补丁的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/silpion/composer-checker&quot;&gt;Composer Checker&lt;/a&gt; -校验Composer配置的工具&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;框架&quot;&gt;框架&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Web开发框架&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://symfony.com/&quot;&gt;Symfony2&lt;/a&gt; -一个独立组件组成的框架&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://framework.zend.com/&quot;&gt;Zend Framework 2&lt;/a&gt; -另一个由独立组件组成的框架&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://laravel.com/&quot;&gt;Laravel 4&lt;/a&gt; -另一个PHP框架&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://auraphp.com/&quot;&gt;Aura PHP&lt;/a&gt; -独立组件的框架&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/yiisoft/yii2/&quot;&gt;Yii2&lt;/a&gt; - 另一个PHP框架&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://nette.org/&quot;&gt;Nette&lt;/a&gt; - 另一个由个体组件组成的框架&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.ppi.io/&quot;&gt;PPI Framework 2&lt;/a&gt; -一个互操作性框架&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://phalconphp.com/en/&quot;&gt;Phalcon&lt;/a&gt; -通过C扩展实现的框架&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##&lt;/p&gt;

&lt;h2 id=&quot;其他框架&quot;&gt;其他框架&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;其他Web开发框架&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/symfony-cmf/symfony-cmf&quot;&gt;Symfony CMF&lt;/a&gt; - 创建自定义CMS的内容管理框架&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://rad.knplabs.com/&quot;&gt;Knp RAD Bundle&lt;/a&gt; -Symfony 2的快速应用程序（RAD）包&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##&lt;/p&gt;

&lt;h2 id=&quot;框架组件&quot;&gt;框架组件&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;来自web开发框架的独立组件&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://symfony.com/doc/master/components/index.html&quot;&gt;Symfony2 Components&lt;/a&gt; -Symfony2组件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://packages.zendframework.com/&quot;&gt;Zend Framework 2 Components&lt;/a&gt; -ZF2组件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://auraphp.github.com/&quot;&gt;Aura Components&lt;/a&gt; -PHP5.4组件包&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://hoa-project.net/En/&quot;&gt;Hoa Project&lt;/a&gt; -另一个PHP组件包&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##&lt;/p&gt;

&lt;h2 id=&quot;微型框架&quot;&gt;微型框架&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;微型框架和路由&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://silex.sensiolabs.org/&quot;&gt;Silex&lt;/a&gt; - 基于Symfony2组件的微型框架&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.slimframework.com/&quot;&gt;Slim&lt;/a&gt; - 另一个简单的微型框架&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://bulletphp.com/&quot;&gt;Bullet PHP&lt;/a&gt; -用于构建REST APIs的微型框架&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/nikic/FastRoute&quot;&gt;Fast Route&lt;/a&gt; - 快速路由库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/c9s/Pux&quot;&gt;Pux&lt;/a&gt; -另一个快速路由库&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;其他微型框架&quot;&gt;其他微型框架&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;其他相关的微型框架和路由&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/fabpot/Silex-Skeleton&quot;&gt;Silex Skeleton&lt;/a&gt; -Silex的项目架构&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/silexphp/Silex-WebProfiler&quot;&gt;Silex Web Profiler&lt;/a&gt; -Silex web调试工具条&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/stackphp&quot;&gt;Stack&lt;/a&gt; - Silex/Symfony的可堆叠中间件库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/codeguy/Slim-Skeleton&quot;&gt;Slim Skeleton&lt;/a&gt; -Slim架构&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/codeguy/Slim-Views&quot;&gt;Slim View&lt;/a&gt; -Slim的自定义视图集合&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/codeguy/Slim-Middleware&quot;&gt;Slim Middleware&lt;/a&gt; -Slim的自定义中间件集合&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##&lt;/p&gt;

&lt;h2 id=&quot;模板&quot;&gt;模板&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;模板化和词法分析的库和工具&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://twig.sensiolabs.org/&quot;&gt;Twig&lt;/a&gt; -一个全面的模板语言&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/asm89/twig-cache-extension&quot;&gt;Twig Cache Extension&lt;/a&gt; -一个用于Twig的模板片段缓存库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/bobthecow/mustache.php&quot;&gt;Mustache&lt;/a&gt; -一个Mustache模板语言的PHP实现&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/weierophinney/phly_mustache&quot;&gt;Phly Mustache&lt;/a&gt; -另一个Mustache模板语言的PHP实现&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/arnaud-lb/MtHaml&quot;&gt;MtHaml&lt;/a&gt; - 一个HAML 模板语言的PHP实现&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://phptal.org/&quot;&gt;PHPTAL&lt;/a&gt; -一个 &lt;a href=&quot;http://en.wikipedia.org/wiki/Template_Attribute_Language&quot;&gt;TAL&lt;/a&gt; 模板语言的PHP实现&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://platesphp.com/&quot;&gt;Plates&lt;/a&gt; -一个原生PHP模板库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/pyrocms/lex&quot;&gt;Lex&lt;/a&gt; -一个轻量级模板解析器&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##&lt;/p&gt;

&lt;h2 id=&quot;静态站点生成器&quot;&gt;静态站点生成器&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;预处理工具来生成web页面的内容。&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://sculpin.io/&quot;&gt;Sculpin&lt;/a&gt; -转换Markdown和Twig为静态HTML的工具&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://phrozn.info/&quot;&gt;Phrozn&lt;/a&gt; - 另一个转换Textile，Markdown和Twig为HTML的工具&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##&lt;/p&gt;

&lt;h2 id=&quot;http&quot;&gt;HTTP&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;用于HTTP和网站爬取的库&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/guzzle/guzzle&quot;&gt;Guzzle&lt;/a&gt; -一个全面的HTTP客户端&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/kriswallsmith/Buzz&quot;&gt;Buzz&lt;/a&gt; -另一个HTTP客户端&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/rmccue/Requests&quot;&gt;Requests&lt;/a&gt; -一个简单的HTTP库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/nategood/httpful&quot;&gt;HTTPFul&lt;/a&gt; -一个链式HTTP库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/fabpot/Goutte&quot;&gt;Goutte&lt;/a&gt; -一个简单的web爬取器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://php-vcr.github.io/&quot;&gt;PHP VCR&lt;/a&gt; -录制和重放HTTP请求的库&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;url&quot;&gt;URL&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;解析URL的库&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/jwage/purl&quot;&gt;Purl&lt;/a&gt; -一个URL处理库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/jeremykendall/php-domain-parser&quot;&gt;PHP Domain Parser&lt;/a&gt; -一个本地前缀解析库&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;email&quot;&gt;Email&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;发送和解析邮件的库&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://swiftmailer.org/&quot;&gt;SwiftMailer&lt;/a&gt; - 一个邮件解决方案&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/PHPMailer/PHPMailer&quot;&gt;PHPMailer&lt;/a&gt; - 另一个邮件解决方案&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/tedivm/Fetch&quot;&gt;Fetch&lt;/a&gt; -一个IMAP库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/willdurand/EmailReplyParser&quot;&gt;Email Reply Parser&lt;/a&gt; -一个邮件回复解析库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/henrikbjorn/Stampie&quot;&gt;Stampie&lt;/a&gt; -邮件服务库，不如 &lt;a href=&quot;http://sendgrid.com/&quot;&gt;SendGrid&lt;/a&gt;, &lt;a href=&quot;http://postmarkapp.com/&quot;&gt;PostMark&lt;/a&gt;, &lt;a href=&quot;http://www.mailgun.com/&quot;&gt;MailGun&lt;/a&gt; 和 &lt;a href=&quot;http://www.mandrill.com/&quot;&gt;Mandrill&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/tijsverkoyen/CssToInlineStyles&quot;&gt;CssToInlineStyles&lt;/a&gt; -一个在邮件模板内联CSS的库&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##&lt;/p&gt;

&lt;h2 id=&quot;文件&quot;&gt;文件&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;文件处理和MIME类型检测库&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/KnpLabs/Gaufrette&quot;&gt;Gaufrette&lt;/a&gt; -一个文件系统抽象层&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/FrenkyNet/Flysystem&quot;&gt;Flysystem&lt;/a&gt; - 另一个文件系统抽象层&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/dflydev/dflydev-canal&quot;&gt;Canal&lt;/a&gt; -一个检测互联网媒体类型的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/dflydev/dflydev-apache-mime-types&quot;&gt;Apache MIME Types&lt;/a&gt; -一个解析Apache MIME类型的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/versionable/Ferret&quot;&gt;Ferret&lt;/a&gt; - 一个MIME检测库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/hoaproject/Mime&quot;&gt;Hoa Mime&lt;/a&gt; -另一个MIME检测库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/henrikbjorn/Lurker&quot;&gt;Lurker&lt;/a&gt; -一个资源跟踪库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/herrera-io/php-file-locator&quot;&gt;PHP File Locator&lt;/a&gt; -一个在大型项目定位文件的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/alchemy-fr/PHP-FFmpeg/&quot;&gt;PHP FFmpeg&lt;/a&gt; -一个用于&lt;a href=&quot;http://www.ffmpeg.org/&quot;&gt;FFmpeg&lt;/a&gt; 视频包装的库.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/nyamsprod/Bakame.csv&quot;&gt;CSV&lt;/a&gt; - 一个CSV数据处理库&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;streams流&quot;&gt;Streams 流&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;处理流的库&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/fzaninotto/Streamer&quot;&gt;Streamer&lt;/a&gt; - 一个面向对象的流包装库&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;dependency-injection依赖注入&quot;&gt;Dependency Injection依赖注入&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;实现依赖注入设计模式的库&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://pimple.sensiolabs.org/&quot;&gt;Pimple&lt;/a&gt; - 一个小的依赖注入容器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/rdlowrey/Auryn&quot;&gt;Auryn&lt;/a&gt; - 另一个依赖注入容器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/orno/di&quot;&gt;Orno Di&lt;/a&gt; -另一个可伸缩的依赖注入容器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://mnapoli.github.com/PHP-DI/&quot;&gt;PHP DI&lt;/a&gt; -一个使用注释实现的依赖注入&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/jeremeamia/acclimate&quot;&gt;Acclimate&lt;/a&gt; -一个依赖注入容器和服务定位的通用接口&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;imagery图像&quot;&gt;Imagery 图像&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;处理图像的库&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://imagine.readthedocs.org/en/latest/index.html&quot;&gt;Imagine&lt;/a&gt; -一个图像处理库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/Sybio/ImageWorkshop&quot;&gt;PHP Image Workshop&lt;/a&gt; -另一个图像处理库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/Intervention/image&quot;&gt;Intervention Image&lt;/a&gt; -另一个图像处理库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/Sybio/GifFrameExtractor&quot;&gt;GIF Frame Extractor&lt;/a&gt; -一个提取GIF动画帧信息的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/Sybio/GifCreator&quot;&gt;GIF Creator&lt;/a&gt; - 一个通过多张图片创建GIF动画的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/nmcteam/image-with-text&quot;&gt;Image With Text&lt;/a&gt; -一个在图像中嵌入文本的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/php-loep/color-extractor&quot;&gt;Color Extractor&lt;/a&gt; -一个从图像中提取颜色的库&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;testing测试&quot;&gt;Testing 测试&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;测试代码和生成测试数据的库&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/sebastianbergmann/phpunit&quot;&gt;PHPUnit&lt;/a&gt; -一个单元测试框架&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/sebastianbergmann/dbunit&quot;&gt;DBUnit&lt;/a&gt; -PHPUnit的数据库测试库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/brianium/paratest&quot;&gt;ParaTest&lt;/a&gt; - PHPUnit的并行测试库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/phpspec/phpspec&quot;&gt;PHPSpec&lt;/a&gt; -基于功能点设计的单元测试库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/Codeception/Codeception&quot;&gt;Codeception&lt;/a&gt; -一个全栈测试框架&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/Codeception/AspectMock&quot;&gt;AspectMock&lt;/a&gt; -  PHPUnit/ Codeception 模拟框架。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/atoum/atoum&quot;&gt;Atoum&lt;/a&gt; -一个简单的测试库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/padraic/mockery&quot;&gt;Mockery&lt;/a&gt; -一个用测试的模拟对象库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/mlively/Phake&quot;&gt;Phake&lt;/a&gt; -另一个用测试的模拟对象库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/phpspec/prophecy&quot;&gt;Prophecy&lt;/a&gt; -一个可选度很高的模拟框架&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/fzaninotto/Faker&quot;&gt;Faker&lt;/a&gt; -一个伪数据生成库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/mauris/samsui&quot;&gt;Samsui&lt;/a&gt; - 另一个伪数据生成库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/nelmio/alice&quot;&gt;Alice&lt;/a&gt; -富有表现力的一代库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://behat.org/&quot;&gt;Behat&lt;/a&gt; -一个行为驱动开发（BDD）测试框架&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/danielstjules/pho&quot;&gt;Pho&lt;/a&gt; -一个行为驱动开发测试框架&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://mink.behat.org/&quot;&gt;Mink&lt;/a&gt; -Web验收测试&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/InterNations/http-mock&quot;&gt;HTTP Mock&lt;/a&gt; - 一个在单元测试模拟HTTP请求的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/mikey179/vfsStream&quot;&gt;VFS Stream&lt;/a&gt; -一个用于测试的虚拟文件系统流的包装器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/adlawson/vfs.php&quot;&gt;VFS&lt;/a&gt; -另一个用于测试虚拟文件系统&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://locust.io/&quot;&gt;Locust&lt;/a&gt; -一个用Python编写的现代加载测试库&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;continuous-integration持续集成&quot;&gt;Continuous Integration 持续集成&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;持续集成的库和应用&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://travis-ci.org/&quot;&gt;Travis CI&lt;/a&gt; - 一个持续集成平台&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.phptesting.org/&quot;&gt;PHPCI&lt;/a&gt; -一个PHP的开源持续集成平台&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://sismo.sensiolabs.org/&quot;&gt;Sismo&lt;/a&gt; - 一个持续测试服务库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://jenkins-ci.org/&quot;&gt;Jenkins&lt;/a&gt;一个 &lt;a href=&quot;http://jenkins-php.org/index.html&quot;&gt;PHP 支持&lt;/a&gt;的持续集成平台&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/jolicode/JoliCi&quot;&gt;JoliCi&lt;/a&gt; - 一个用PHP编写的由Docker支持的持续集成客户端&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;documentation文档&quot;&gt;Documentation 文档&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;生成项目文档的库&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/fabpot/Sami&quot;&gt;Sami&lt;/a&gt; -一个API文档生成器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/apigen/apigen&quot;&gt;APIGen&lt;/a&gt; -另一个API文档生成器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/phpDocumentor/phpDocumentor2&quot;&gt;PHP Documentor 2&lt;/a&gt; -一个API文档生成器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://phpdox.de/&quot;&gt;phpDox&lt;/a&gt; - 一个PHP项目的文档生成器（不限于API文档）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;security安全&quot;&gt;Security 安全&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;生成安全的随机数，加密数据，扫描漏洞的库&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ezyang/htmlpurifier&quot;&gt;HTML Purifier&lt;/a&gt; -一个兼容标准的HTML过滤器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ircmaxell/RandomLib&quot;&gt;RandomLib&lt;/a&gt; -一个生成随机数和字符串的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/pixeloution/true-random&quot;&gt;True Random&lt;/a&gt; -使用 &lt;a href=&quot;http://www.random.org/&quot;&gt;www.random.org&lt;/a&gt;生成随机数的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/padraic/SecurityMultiTool&quot;&gt;SecurityMultiTool&lt;/a&gt; -一个PHP安全库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://phpseclib.sourceforge.net/&quot;&gt;PHPSecLib&lt;/a&gt; -一个纯PHP安全通信库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/timoh6/TCrypto&quot;&gt;TCrypto&lt;/a&gt; -一个简单的键值加密存储库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/PHPIDS/PHPIDS&quot;&gt;PHP IDS&lt;/a&gt; - 一个结构化的PHP安全层&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/Herzult/php-ssh&quot;&gt;PHP SSH&lt;/a&gt; -一个试验的面向对象的SSH包装库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/psecio/iniscan&quot;&gt;IniScan&lt;/a&gt; -一个扫描PHP INI文件安全的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://security.sensiolabs.org/&quot;&gt;SensioLabs Security Check&lt;/a&gt; -一个为检查Composer依赖提供安全建议的web工具&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project&quot;&gt;Zed&lt;/a&gt; - 一个集成的web应用渗透测试工具&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;passwords密码&quot;&gt;Passwords 密码&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;处理和存储密码的库和工具&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ircmaxell/password_compat&quot;&gt;Password Compat&lt;/a&gt; -一个新的PHP5.5密码函数的兼容库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.openwall.com/phpass/&quot;&gt;phpass&lt;/a&gt; - 一个便携式的密码哈希框架&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ircmaxell/PHP-PasswordLib&quot;&gt;PHP Password Lib&lt;/a&gt; -一个生成和校验密码的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ircmaxell/password-policy&quot;&gt;Password Policy&lt;/a&gt; - 一个PHP和JavaScript的密码策略库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/jeremykendall/password-validator&quot;&gt;Password Validator&lt;/a&gt; - 校验和升级密码哈希的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/bjeavons/zxcvbn-php&quot;&gt;Zxcvbn PHP&lt;/a&gt; -一个基于Zxcvbn JS的现实的PHP密码强度估计库&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;code-analysis代码分析&quot;&gt;Code Analysis 代码分析&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;分析，解析和处理代码库的库的工具&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/nikic/PHP-Parser&quot;&gt;PHP Parser&lt;/a&gt; -一个PHP编写的PHP解析器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ircmaxell/PHPPHP&quot;&gt;PHPPHP&lt;/a&gt; - 一个PHP实现的PHP虚拟机&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/fieryprophet/php-sandbox&quot;&gt;PHPSandbox&lt;/a&gt; -一个PHP沙盒环境&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/jakubledl/dissect&quot;&gt;Dissect&lt;/a&gt; -一个词法和语法分析的工具集合&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://phpmd.org/&quot;&gt;PHP Mess Detector&lt;/a&gt; -一个扫描代码缺陷,次优代码，未使用的参数等等的库。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/squizlabs/PHP_CodeSniffer&quot;&gt;PHP Code Sniffer&lt;/a&gt; -一个检测PHP、CSS和JS代码标准冲突的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/sebastianbergmann/phpcpd&quot;&gt;PHPCPD&lt;/a&gt; - 一个检测复制和粘贴代码的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/scrutinizer-ci/php-analyzer&quot;&gt;PHP Analyser&lt;/a&gt; -一个分析PHP代码查找缺陷和错误的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/fabpot/PHP-CS-Fixer&quot;&gt;PHP CS Fixer&lt;/a&gt; - 一个编码标准库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/schmittjoh/php-manipulator&quot;&gt;PHP Manipulator&lt;/a&gt; -一个分析和修改PHP源代码的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/Halleck45/PhpMetrics&quot;&gt;PHP Metrics&lt;/a&gt; -一个静态测量库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/QafooLabs/php-refactoring-browser&quot;&gt;PHP Refactoring Browser&lt;/a&gt; -一个重构PHP代码的命令行工具集&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/devster/ubench&quot;&gt;UBench&lt;/a&gt; - 一个简单的微型基准检测库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/polyfractal/athletic&quot;&gt;Athletic&lt;/a&gt; -一个基于注释的基准检测库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/Trismegiste/Mondrian&quot;&gt;Mondrian&lt;/a&gt; - 使用使用图论的代码分析工具&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://scrutinizer-ci.com/&quot;&gt;Scrutinizer&lt;/a&gt; -一个审查PHP代码的web工具&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/sebastianbergmann/phploc&quot;&gt;PHPLOC&lt;/a&gt; -一个快速测量PHP项目大小的工具&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/phacility/xhprof&quot;&gt;xHprof&lt;/a&gt; -另一个PHP分析工具&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/jbrooksuk/phpcheckstyle&quot;&gt;PHPCheckstyle&lt;/a&gt; -一个帮助遵守特定的编码惯例的工具。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;##&lt;/p&gt;

&lt;h2 id=&quot;debugging调试&quot;&gt;Debugging 调试&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;调试代码的库和工具&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/xdebug/xdebug&quot;&gt;xDebug&lt;/a&gt; -一个调试和分析PHP的工具&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://phpdebugbar.com/&quot;&gt;PHP Debug Bar&lt;/a&gt; - 一个调试工具栏&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/Seldaek/php-console&quot;&gt;PHP Console&lt;/a&gt; -一个web调试控制台&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/barbushin/php-console&quot;&gt;Barbushin PHP Console&lt;/a&gt; -另一个使用Google Chrome的web调试控制台&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://phpdbg.com/&quot;&gt;PHPDBG&lt;/a&gt; - 一个交互的PHP调试器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/nette/tracy&quot;&gt;Tracy&lt;/a&gt; -一个简单的错误检测，写日志和时间测量库&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;build-tools构建工具&quot;&gt;Build Tools 构建工具&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;项目构建和自动化工具&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/herrera-io/php-go&quot;&gt;Go&lt;/a&gt; -一个简单的PHP构建工具&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/CHH/bob&quot;&gt;Bob&lt;/a&gt; - 一个简单的项目自动化工具&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/jaz303/phake&quot;&gt;Phake&lt;/a&gt; -一个PHP克隆库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/kherge/Box&quot;&gt;Box&lt;/a&gt; - 一个构建PHAR文件的工具&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.phing.info/&quot;&gt;Phing&lt;/a&gt; -一个灵感来自于Apache Ant的PHP项目构建系统&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;task-runners任务运行器&quot;&gt;Task Runners 任务运行器&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;自动运行任务的库&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://taskphp.github.io/&quot;&gt;Task&lt;/a&gt; -一个灵感来源于Grunt和Gulp的纯PHP任务运行器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/Codegyre/Robo&quot;&gt;Robo&lt;/a&gt; -一个面向对象配置的PHP任务运行器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://bldr.io/&quot;&gt;Bldr&lt;/a&gt; -一个构建在Symfony组件上的PHP任务运行器&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;navigation导航&quot;&gt;Navigation导航&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;构建导航结构的工具&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/KnpLabs/KnpMenu&quot;&gt;KnpMenu&lt;/a&gt; - 一个菜单库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/tackk/cartographer&quot;&gt;Cartographer&lt;/a&gt; -一个站点地图生成库&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;asset-management资源管理&quot;&gt;Asset Management 资源管理&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;管理，压缩和最小化web站点资源的工具&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/kriswallsmith/assetic&quot;&gt;Assetic&lt;/a&gt; - 一个资源管理的管道库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/CHH/pipe&quot;&gt;Pipe&lt;/a&gt; -另一个资源管理的管道库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/meenie/munee&quot;&gt;Munee&lt;/a&gt; -一个资源优化库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/tedivm/JShrink&quot;&gt;JShrink&lt;/a&gt; -一个JavaScript最小化库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/webmozart/puli&quot;&gt;Puli&lt;/a&gt; - 一个检测资源绝对路径的库&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;geolocation地理位置&quot;&gt;Geolocation 地理位置&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;为地理编码地址和使用纬度经度的库。&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://geocoder-php.org/&quot;&gt;GeoCoder&lt;/a&gt; -一个地理编码库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/php-loep/Geotools&quot;&gt;GeoTools&lt;/a&gt; -一个地理工具相关的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/mjaschen/phpgeo&quot;&gt;PHPGeo&lt;/a&gt; -一个简单的地理库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/jmikola/geojson&quot;&gt;GeoJSON&lt;/a&gt; -一个地理JSON的实现&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;date-and-time日期和时间&quot;&gt;Date and Time 日期和时间&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;处理日期和时间的库&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/briannesbitt/Carbon&quot;&gt;Carbon&lt;/a&gt; - 一个简单的日期时间API扩展&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/jasonlewis/expressive-date&quot;&gt;ExpressiveDate&lt;/a&gt; -另一个日期时间API扩展&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://yohan.giarel.li/CalendR&quot;&gt;CalendR&lt;/a&gt; - 一个日历管理库&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;event事件&quot;&gt;Event 事件&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;时间驱动或非阻塞事件循环实现的库&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/reactphp/react&quot;&gt;React&lt;/a&gt; -一个事件驱动的非阻塞I/O库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/asm89/Rx.PHP&quot;&gt;Rx.PHP&lt;/a&gt; - 一个reactive扩展库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/cboden/Ratchet&quot;&gt;Ratchet&lt;/a&gt; - 一个web套接字库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/hoaproject/Websocket&quot;&gt;Hoa WebSocket&lt;/a&gt; -另一个web套接字库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/hoaproject/Eventsource&quot;&gt;Hoa EventSource&lt;/a&gt; -一个事件源库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/igorw/evenement&quot;&gt;Evenement&lt;/a&gt; -一个事件分发库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/fuelphp/event&quot;&gt;FuelPHP Event&lt;/a&gt; -另一个事件分发库&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;logging日志&quot;&gt;Logging 日志&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;生成和处理日志文件的库&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/Seldaek/monolog&quot;&gt;Monolog&lt;/a&gt; - 一个全面的日志工具&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/katzgrau/KLogger&quot;&gt;KLogger&lt;/a&gt; -一个易用的PSR-3兼容的日志类&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;e-commerce电子商务&quot;&gt;E-commerce 电子商务&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;处理支付和构建在线电子商务商店的库和应用&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/adrianmacneil/omnipay&quot;&gt;OmniPay&lt;/a&gt; -一个框架混合了多网关支付处理的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/payum/payum&quot;&gt;Payum&lt;/a&gt; - 一个支付抽象库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.sylius.org/&quot;&gt;Sylius&lt;/a&gt; - 一个开源的电子商务解决方案&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://thelia.net/v2/&quot;&gt;Thelia&lt;/a&gt; -另一个开源的电子商务解决方案&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/mathiasverraes/money&quot;&gt;Money&lt;/a&gt; - 一个Fowler金钱模式的PHP实现&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/sebastianbergmann/money&quot;&gt;Sebastian Money&lt;/a&gt; -另一个处理货币值的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/florianv/swap&quot;&gt;Swap&lt;/a&gt; -一个汇率库&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;pdf&quot;&gt;PDF&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;处理PDF文件的库和软件&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/KnpLabs/snappy&quot;&gt;Snappy&lt;/a&gt; -一个PDF和图像生成器库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/antialize/wkhtmltopdf&quot;&gt;WKHTMLToPDF&lt;/a&gt; -一个将HTML转换为PDF的工具&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;database数据库&quot;&gt;Database 数据库&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;使用对象关系映射（ORM）或数据映射技术的数据库交互库&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.doctrine-project.org/&quot;&gt;Doctrine&lt;/a&gt; -一个全面的DBAL和ORM&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/l3pp4rd/DoctrineExtensions&quot;&gt;Doctrine Extensions&lt;/a&gt; -一个Doctrine行为扩展的集合&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.propelorm.org/&quot;&gt;Propel&lt;/a&gt; - 一个快速的ORM，迁移库和查询构架器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/illuminate/database&quot;&gt;Eloquent&lt;/a&gt; -Laravel 4 ORM&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/etrepat/baum&quot;&gt;Baum&lt;/a&gt; -一个Eloquent的嵌套集实现&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/vlucas/spot2&quot;&gt;Spot2&lt;/a&gt; -一个MySQL的ORM映射器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://redbeanphp.com/&quot;&gt;RedBean&lt;/a&gt; -一个轻量级，低配置的ORM&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/chanmix51/Pomm&quot;&gt;Pomm&lt;/a&gt; -一个PostgreSQL对象模型管理器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/Ocramius/ProxyManager&quot;&gt;ProxyManager&lt;/a&gt; -一个为数据映射生成代理对象的工具集&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;migrations迁移&quot;&gt;Migrations 迁移&lt;/h2&gt;

&lt;p&gt;帮助管理数据库模式和迁移的库&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/davedevelopment/phpmig&quot;&gt;PHPMig&lt;/a&gt; -另一个迁移管理库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/robmorgan/phinx&quot;&gt;Phinx&lt;/a&gt; - 另一个数据库迁移管理库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/icomefromthenet/Migrations&quot;&gt;Migrations&lt;/a&gt; -一个迁移管理库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://docs.doctrine-project.org/projects/doctrine-migrations/en/latest/toc.html&quot;&gt;Doctrine Migrations&lt;/a&gt; -一个Doctrine迁移库&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;nosql&quot;&gt;NoSQL&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;处理NoSQL后端的库&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/alexbilbie/MongoQB&quot;&gt;MongoQB&lt;/a&gt; -一个MongoDB查询构建库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/thephpleague/monga&quot;&gt;Monga&lt;/a&gt; -一个MongoDB抽象库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/nrk/predis&quot;&gt;Predis&lt;/a&gt; - 一个功能完整的Redis库&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;queue队列&quot;&gt;Queue 队列&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;处理事件和任务队列的库&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/pda/pheanstalk&quot;&gt;Pheanstalk&lt;/a&gt; -一个Beanstalkd 客户端库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/videlalvaro/php-amqplib&quot;&gt;PHP AMQP&lt;/a&gt; -一个纯PHP AMQP库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/videlalvaro/Thumper&quot;&gt;Thumper&lt;/a&gt; - 一个RabbitMQ模式库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/bernardphp/bernard&quot;&gt;Bernard&lt;/a&gt; -一个多后端抽象库&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;search搜索&quot;&gt;Search 搜索&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;在数据上索引和执行查询的库和软件&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/elasticsearch/elasticsearch-php&quot;&gt;ElasticSearch PHP&lt;/a&gt; -ElasticSearch的官方客户端库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ruflin/Elastica&quot;&gt;Elastica&lt;/a&gt; -ElasticSearch的客户端库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.solarium-project.org/&quot;&gt;Solarium&lt;/a&gt; -Solr的客户端库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://foolcode.github.io/SphinxQL-Query-Builder/&quot;&gt;SphinxQL query builder&lt;/a&gt; -Sphinx搜索引擎的的查询库&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;command-line命令行&quot;&gt;Command Line 命令行&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;构建命令行工具的库&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/d11wtq/boris&quot;&gt;Boris&lt;/a&gt; - 一个微型PHP REPL&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/bobthecow/psysh&quot;&gt;PsySH&lt;/a&gt; - 另一个微型PHP REPL&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/mcrumm/pecan&quot;&gt;Pecan&lt;/a&gt; -一个事件驱动和非阻塞内核&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ulrichsg/getopt-php&quot;&gt;GetOpt&lt;/a&gt; - 一个命令行选择解析器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/CHH/optparse&quot;&gt;OptParse&lt;/a&gt; -另一个命令行选择解析器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/nategood/commando&quot;&gt;Commando&lt;/a&gt; -另一个简单的命令行选择解析器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/c9s/php-GetOptionKit&quot;&gt;GetOptionKit&lt;/a&gt; -另一个命令行选择解析器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/mtdowling/cron-expression&quot;&gt;Cron Expression&lt;/a&gt; -计算cron运行日期的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/MrRio/shellwrap&quot;&gt;ShellWrap&lt;/a&gt; -一个简单的命令行包装库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/hoaproject/Console&quot;&gt;Hoa Console&lt;/a&gt; -另一个命令行库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/php-loep/shunt&quot;&gt;Shunt&lt;/a&gt; - 一个在多台远程机器上并行运行命令行的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/Cilex/Cilex&quot;&gt;Cilex&lt;/a&gt; -一个构建命令行工具的微型框架&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;authentication身份验证&quot;&gt;Authentication 身份验证&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;实现身份验证的库&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/cartalyst/sentry&quot;&gt;Sentry&lt;/a&gt; -一个混合的身份验证和授权的框架库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://docs.cartalyst.com/sentry-social-2/introduction&quot;&gt;Sentry Social&lt;/a&gt; -一个社交网络身份验证库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/opauth/opauth&quot;&gt;Opauth&lt;/a&gt; -一个多渠道的身份验证框架&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/php-loep/oauth2-server&quot;&gt;OAuth2&lt;/a&gt; -一个OAuth2身份验证服务，资源服务器和客户端库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://bshaffer.github.io/oauth2-server-php-docs/&quot;&gt;OAuth2 Server&lt;/a&gt; -另一个OAuth2服务器实现&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/Lusitanian/PHPoAuthLib&quot;&gt;PHP oAuthLib&lt;/a&gt; -另一个OAuth库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ruudk/twitteroauth&quot;&gt;TwitterOAuth&lt;/a&gt; -一个Twitter OAuth库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/lyrixx/twitter-sdk&quot;&gt;TwitterSDK&lt;/a&gt; -一个完全测试的Twitter SDK&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/dflydev/dflydev-hawk&quot;&gt;Hawk&lt;/a&gt; -一个Hawk HTTP身份认证库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/hybridauth/hybridauth&quot;&gt;HybridAuth&lt;/a&gt; -一个开源的社交登陆库&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;markup标记&quot;&gt;Markup 标记&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;处理标记的库&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://milesj.me/code/php/decoda&quot;&gt;Decoda&lt;/a&gt; -一个轻量级标记解析库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/michelf/php-markdown&quot;&gt;PHP Markdown&lt;/a&gt; -一个Markdown解析器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/thephpleague/commonmark&quot;&gt;CommonMark PHP&lt;/a&gt; -一个对 &lt;a href=&quot;https://jgm.github.io/stmd/spec.html&quot;&gt;CommonMark spec&lt;/a&gt;全支持的Markdown解析器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/dflydev/dflydev-markdown&quot;&gt;Dflydev Markdown&lt;/a&gt; -另一个Markdown解析器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/erusev/parsedown&quot;&gt;Parsedown&lt;/a&gt; -另一个Markdown解析器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/kzykhys/Ciconia&quot;&gt;Ciconia&lt;/a&gt; - 另一个支持Github Markdown风格的Markdown解析器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/cebe/markdown&quot;&gt;Cebe Markdown&lt;/a&gt; -一个快速的可扩展的Markdown解析器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/Masterminds/html5-php&quot;&gt;HTML5 PHP&lt;/a&gt; - 一个HTML5解析和序列化库&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;strings字符串&quot;&gt;Strings 字符串&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;解析和处理字符串的库&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/sensiolabs/ansi-to-html&quot;&gt;ANSI to HTML5&lt;/a&gt; -ANSI到HTML5的转化库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/nicolas-grekas/Patchwork-UTF8&quot;&gt;Patchwork UTF-8&lt;/a&gt; -一个处理UTF-8字符串的便携库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/hoaproject/String&quot;&gt;Hoa String&lt;/a&gt; -另一个UTF-8字符串库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/danielstjules/Stringy&quot;&gt;Stringy&lt;/a&gt; -一个多字节支持的字符串处理库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/mikeemoo/ColorJizz-PHP&quot;&gt;Color Jizz&lt;/a&gt; -处理和转换颜色的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ramsey/uuid&quot;&gt;UUID&lt;/a&gt; - 生成UUIDs的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/cocur/slugify&quot;&gt;Slugify&lt;/a&gt; -转换字符串到slug的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/jbroadway/urlify&quot;&gt;Urlify&lt;/a&gt; - 一个Django的 URLify.jsPHP通道&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/kzykhys/Text&quot;&gt;Text&lt;/a&gt; - 一个文本处理库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/jdorn/sql-formatter/&quot;&gt;SQL Formatter&lt;/a&gt; -一个格式化SQL语句的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/tobie/ua-parser/tree/master/php&quot;&gt;UA Parser&lt;/a&gt; - 一个解析用户代理字符串的库&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;numbers数字&quot;&gt;Numbers 数字&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;处理数字的库&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/powder96/numbers.php&quot;&gt;Numbers PHP&lt;/a&gt; -处理数字的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/moontoast/math&quot;&gt;Math&lt;/a&gt; -处理大数字的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/gabrielelana/byte-units&quot;&gt;ByteUnits&lt;/a&gt; - 在二进制和度量系统中解析,格式化和转换字节单元的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/triplepoint/php-units-of-measure&quot;&gt;PHP Units of Measure&lt;/a&gt; -一个计量单位转换的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/Crisu83/php-conversion&quot;&gt;PHP Conversion&lt;/a&gt; - 另一个计量单位转换的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/giggsey/libphonenumber-for-php&quot;&gt;LibPhoneNumber for PHP&lt;/a&gt; -Google电话号码处理的PHP实现库&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;filtering-and-validation过滤和验证&quot;&gt;Filtering and Validation 过滤和验证&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;过滤和验证数据的库&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ircmaxell/filterus&quot;&gt;Filterus&lt;/a&gt; - 一个简单的PHP过滤库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/Respect/Validation&quot;&gt;Respect Validate&lt;/a&gt; -一个简单的验证库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/vlucas/valitron&quot;&gt;Valitron&lt;/a&gt; -另一个验证库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/codeguy/Upload&quot;&gt;Upload&lt;/a&gt; - 一个处理文件上传和验证的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/rdohms/DMS-Filter&quot;&gt;DMS Filter&lt;/a&gt; - 一个注释过滤库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/romaricdrigon/MetaYaml&quot;&gt;MetaYaml&lt;/a&gt; -一个支持YAML,JSON和XML的模式验证库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ronanguilloux/IsoCodes&quot;&gt;ISO-codes&lt;/a&gt; -验证各种ISO和ZIP编码的库(IBAN, SWIFT/BIC, BBAN, VAT, SSN, UKNIN)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;rest和api&quot;&gt; REST和API&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;开发REST-ful API的库和web工具&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/zfcampus/zf-apigility-skeleton&quot;&gt;Apigility&lt;/a&gt; -一个使用Zend Framework 2构建的API构建器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/willdurand/Hateoas&quot;&gt;Hateoas&lt;/a&gt; -一个HOATEOAS REST web服务库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/blongden/hal&quot;&gt;HAL&lt;/a&gt; -一个超文本应用语言（HAL)构建库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/willdurand/Negotiation&quot;&gt;Negotiation&lt;/a&gt; -一个内容协商库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/leedavis81/drest&quot;&gt;Drest&lt;/a&gt; -一个将Doctrine实体暴露为REST资源节点的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/Luracast/Restler&quot;&gt;Restler&lt;/a&gt; -一个将PHP方法暴露为RESTful web API的轻量级框架&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;caching缓存&quot;&gt;Caching 缓存&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;缓存数据的库&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.php.net/manual/en/book.apc.php&quot;&gt;Alternative PHP Cache (APC)&lt;/a&gt; - 打开PHP伪代码缓存&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/doctrine/cache&quot;&gt;Cache&lt;/a&gt; -一个缓存库（Doctrine部分）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/tedivm/Stash&quot;&gt;Stash&lt;/a&gt; -另一个缓存库&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;数据结构和存储&quot;&gt;数据结构和存储&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;实现数据结构和存储技术的库&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/morrisonlevi/Ardent&quot;&gt;Ardent&lt;/a&gt; -一个数据结构库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/schmittjoh/php-collection&quot;&gt;PHP Collections&lt;/a&gt; - 一个简单的集合库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/schmittjoh/serializer&quot;&gt;Serializer&lt;/a&gt; -一个序列化和反序列化数据的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/herrera-io/php-object-storage&quot;&gt;PHP Object Storage&lt;/a&gt; -一个对象存储库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/php-loep/fractal&quot;&gt;Fractal&lt;/a&gt; -一个转换复杂数据结构到JSON输出的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://github.com/Wisembly/Totem&quot;&gt;Totem&lt;/a&gt; -一个管理和穿件数据交换集的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/TimeToogo/Pinq&quot;&gt;PINQ&lt;/a&gt; -一个PHP实时Linq库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/netresearch/jsonmapper&quot;&gt;JsonMapper&lt;/a&gt; -一个将内嵌JSON结构映射为PHP类的库&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;notifications通知&quot;&gt;Notifications 通知&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;处理通知软件的库&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/filp/nod&quot;&gt;Nod&lt;/a&gt; -一个通知库（Growl等）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/wrep/notificato&quot;&gt;Notificato&lt;/a&gt; - 一个处理推送通知的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/Ph3nol/NotificationPusher&quot;&gt;Notification Pusher&lt;/a&gt; -一个设备推送通知的独立库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/namshi/notificator&quot;&gt;Notificator&lt;/a&gt; -一个轻量级的通知库&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;deployment部署&quot;&gt;Deployment 部署&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;项目部署库&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/tamagokun/pomander&quot;&gt;Pomander&lt;/a&gt; -一个PHP应用部署工具&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/Anahkiasen/rocketeer&quot;&gt;Rocketeer&lt;/a&gt; -PHP世界里的一个快速简单的部署器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/laravel/envoy&quot;&gt;Envoy&lt;/a&gt; -一个用PHP运行SSH任务的工具&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/aerialls/Plum&quot;&gt;Plum&lt;/a&gt; - 一个部署库&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;国际化和本地化&quot;&gt;国际化和本地化&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;国际化（I18n）和本地化（L10n）&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/auraphp/Aura.Intl&quot;&gt;Aura.Intl&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;第三方api&quot;&gt;第三方API&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;访问第三方API的库&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/aws/aws-sdk-php&quot;&gt;Amazon Web Service SDK&lt;/a&gt; - PHP AWS SDK官方库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/gwkunze/S3StreamWrapper&quot;&gt;S3 Stream Wrapper&lt;/a&gt; -Amazon S3流包装库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/stripe/stripe-php&quot;&gt;Stripe&lt;/a&gt; -Stripe官方PHP库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://campaignmonitor.github.com/createsend-php/&quot;&gt;Campaign Monitor&lt;/a&gt; -Campaign Monitor官方PHP库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/toin0u/DigitalOcean&quot;&gt;Digital Ocean&lt;/a&gt; -Digital Ocean API 接口库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/dsyph3r/github-api3-php&quot;&gt;Github&lt;/a&gt; - Github API交互库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/KnpLabs/php-github-api&quot;&gt;PHP Github API&lt;/a&gt; -另一个Github API交互库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/widop/twitter-oauth&quot;&gt;Twitter OAuth&lt;/a&gt; -Twitter OAuth工作流交互库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/widop/twitter-rest&quot;&gt;Twitter REST&lt;/a&gt; - Twitter REST API交互库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/dropbox/dropbox-sdk-php&quot;&gt;Dropbox SDK&lt;/a&gt; - The official PHP Dropbox SDK library.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/dropbox/dropbox-sdk-php&quot;&gt;Dropbox SDK&lt;/a&gt; - Dropbox SDK官方PHP库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/twilio/twilio-php&quot;&gt;Twilio&lt;/a&gt; - The official Twilio PHP REST API.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/twilio/twilio-php&quot;&gt;Twilio&lt;/a&gt; - Twilio官方PHP REST API&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/mailgun/mailgun-php&quot;&gt;Mailgun&lt;/a&gt; The official Mailgun PHP API.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/mailgun/mailgun-php&quot;&gt;Mailgun&lt;/a&gt; Mailgun官方PHP REST API&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;extensions扩展&quot;&gt;Extensions 扩展&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;帮组构建PHP扩展的库&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/phalcon/zephir&quot;&gt;Zephir&lt;/a&gt; -用于开发PHP扩展，且介于PHP和C++之间的编译语言&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.php-cpp.com/&quot;&gt;PHP CPP&lt;/a&gt; -一个开发PHP扩展的C++库&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;miscellaneous杂项&quot;&gt;Miscellaneous 杂项&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;不在上面分类中的有用库和工具&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/kriswallsmith/spork&quot;&gt;Spork&lt;/a&gt; -一个处理forking的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/Seldaek/jsonlint&quot;&gt;JSON Lint&lt;/a&gt; - 一个JSON lint工具&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/willdurand/JsonpCallbackValidator&quot;&gt;JSONPCallbackValidator&lt;/a&gt; -验证JSONP回调的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/whiteoctober/Pagerfanta&quot;&gt;Pagerfanta&lt;/a&gt; -一个分页库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/bobthecow/Ruler&quot;&gt;Ruler&lt;/a&gt; - 一个简单的无状态的生产环境规则引擎。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/beberlei/litecqrs-php&quot;&gt;LiteCQRS&lt;/a&gt; -一个CQRS(命令查询责任分离)库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/EvanDotPro/Sslurp&quot;&gt;Sslurp&lt;/a&gt; - 一个使得SSL处理减少的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/schmittjoh/php-option&quot;&gt;PHP Option&lt;/a&gt;一个可选的类型库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/beberlei/metrics&quot;&gt;Metrics&lt;/a&gt; -一个简单的度量API库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/evert/sabre-vobject&quot;&gt;Sabre VObject&lt;/a&gt; - 一个解析VCard和iCalendar对象的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/doctrine/annotations&quot;&gt;Annotations&lt;/a&gt; -一个注释库（Doctrine部分）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/filp/whoops&quot;&gt;Whoops&lt;/a&gt; -一个不错的错误处理库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://yohan.giarel.li/Finite&quot;&gt;Finite&lt;/a&gt; -一个简单的PHP有限状态机&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/raulfraile/Ladybug&quot;&gt;LadyBug&lt;/a&gt; -一个dumper库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/lstrojny/Procrastinator&quot;&gt;Procrastinator&lt;/a&gt; -运行耗时任务的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/igorw/compose&quot;&gt;Compose&lt;/a&gt; -一个功能组合库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/jeremeamia/super_closure&quot;&gt;SuperClosure&lt;/a&gt; -一个允许闭包序列化的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/kakawait/Jumper&quot;&gt;Jumper&lt;/a&gt; - 一个远程服务执行库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://anahkiasen.github.io/underscore-php/&quot;&gt;Underscore&lt;/a&gt; -一个Undersccore JS库的PHP实现&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/eymengunay/php-passbook&quot;&gt;PHP PassBook&lt;/a&gt; -一个iOS PassBook PHP库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/Kitano/php-expression&quot;&gt;PHP Expression&lt;/a&gt; -一个PHP表达式语言&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/liip/RMT&quot;&gt;RMT&lt;/a&gt; - 一个编写版本和发布软件的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/herrera-io/php-wise&quot;&gt;Wise&lt;/a&gt; - 一个配置管理器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/euskadi31/Opengraph&quot;&gt;Opengraph&lt;/a&gt; -一个开放图库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/felixgirault/essence&quot;&gt;Essence&lt;/a&gt; -一个提取web媒体的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/mpratt/Embera&quot;&gt;Embera&lt;/a&gt; -一个Oembed消费库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/alexandresalome/graphviz&quot;&gt;Graphviz&lt;/a&gt; -一个图形库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ircmaxell/monad-php&quot;&gt;Monad PHP&lt;/a&gt; 一个简单Monad库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/selvinortiz/flux&quot;&gt;Flux&lt;/a&gt; -一个正则表达式构建库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://antecedent.github.io/patchwork/&quot;&gt;Patchwork&lt;/a&gt; - 一个重新定义用户的函数库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/igorw/galapagos&quot;&gt;Galapagos&lt;/a&gt; -语言转换进化&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/domnikl/DesignPatternsPHP&quot;&gt;Design Patterns PHP&lt;/a&gt; -一个使用PHP实现的设计模式存储库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/phpcr/phpcr&quot;&gt;PHPCR&lt;/a&gt; - 一个Java内容存储库（JCR)的PHP实现&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/lstrojny/functional-php&quot;&gt;Functional PHP&lt;/a&gt; - 一个函数式编程库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/mtdowling/ClassPreloader&quot;&gt;ClassPreloader&lt;/a&gt; - 一个优化自动加载的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/phine/lib-country&quot;&gt;Lib Country&lt;/a&gt; -一个国家和地区数据的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/phine/lib-accessor&quot;&gt;Lib Accessor&lt;/a&gt; -一个简化访问的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://dunkels.com/adam/phpstack/&quot;&gt;PHPStack&lt;/a&gt; -一个PHP编写的TCP/IP栈概念&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/willdurand/nmap&quot;&gt;Nmap&lt;/a&gt; -一个Nmap PHP包装器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/dantleech/code-mover&quot;&gt;Code Mover&lt;/a&gt; -一个移动代码的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/nikic/iter&quot;&gt;Iter&lt;/a&gt; -一个使用生成器提供迭代原语的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/igorw/lambda-php&quot;&gt;Lambda PHP&lt;/a&gt; -一个PHP中的Lambda 计算解析器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/umpirsky/country-list&quot;&gt;Country List&lt;/a&gt; - 所有带有名称和ISO 3166-1编码的国家列表&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ronanguilloux/php-gpio&quot;&gt;PHP-GPIO&lt;/a&gt; - 用于Raspberry PI的GPIO pin的库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/koriym/print_o&quot;&gt;print_o&lt;/a&gt; - 一个对象图的可视化器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/fuelphp/alias&quot;&gt;Alias&lt;/a&gt; -一个类别名库&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;software软件&quot;&gt;Software 软件&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;创建一个开发环境的软件&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;php安装&quot;&gt;PHP安装&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;在你的电脑上帮助安装和管理PHP的工具&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://mxcl.github.com/homebrew/&quot;&gt;HomeBrew&lt;/a&gt; -一个OSX包管理器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/josegonzalez/homebrew-php&quot;&gt;HomeBrew PHP&lt;/a&gt; -一个HomeBrew的PHP通道&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://php-osx.liip.ch/&quot;&gt;PHP OSX&lt;/a&gt; - 一个OSX下的PHP安装器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/c9s/phpbrew&quot;&gt;PHP Brew&lt;/a&gt; -一个PHP版本管理和安装器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/CHH/phpenv&quot;&gt;PHP Env&lt;/a&gt; - 另一个PHP版本管理器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/jubianchi/phpswitch&quot;&gt;PHP Switch&lt;/a&gt; - 另一个PHP版本管理器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/CHH/php-build&quot;&gt;PHP Build&lt;/a&gt; - 另一个PHP版本安装器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://virtphp.org/&quot;&gt;VirtPHP&lt;/a&gt; - 一个创建和管理独立PHP环境的工具&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;development-environment开发环境&quot;&gt;Development Environment 开发环境&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;创建沙盒开发环境的软件和工具&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.vagrantup.com/&quot;&gt;Vagrant&lt;/a&gt; -一个便携的开发环境工具&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.ansibleworks.com/&quot;&gt;Ansible&lt;/a&gt; - 一个非常简单的编制框架&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://puppetlabs.com/&quot;&gt;Puppet&lt;/a&gt; -一个服务器自动化框架和应用&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://puphpet.com/&quot;&gt;PuPHPet&lt;/a&gt; -一个构建PHP开发虚拟机的web工具&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://getprotobox.com/&quot;&gt;Protobox&lt;/a&gt; -另一个构建PHP开发虚拟机的web工具&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://phansible.com/&quot;&gt;Phansible&lt;/a&gt; - 一个用Ansible构建PHP开发虚拟机的web工具&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;virtual-machines虚拟机&quot;&gt;Virtual Machines 虚拟机&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;相关的PHP虚拟机&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/facebook/hiphop-php&quot;&gt;HipHop PHP&lt;/a&gt; -Facebook出品的PHP虚拟机，运行时和JIT&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://hippyvm.com/&quot;&gt;HippyVM&lt;/a&gt; -另一个PHP虚拟机&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://hacklang.org/&quot;&gt;Hack&lt;/a&gt; - 一个PHP进行无缝操作的 &lt;a href=&quot;https://github.com/facebook/hiphop-php&quot;&gt;HHVM&lt;/a&gt;编程语言&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ide集成开发环境&quot;&gt;IDE 集成开发环境&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;支持PHP的集成开发环境&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://netbeans.org/&quot;&gt;Netbeans&lt;/a&gt; -一个支持PHP和HTML5的IDE&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.eclipse.org/downloads/&quot;&gt;Eclipse for PHP Developers&lt;/a&gt; -一个基于Eclipse平台的PHP IDE&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.jetbrains.com/phpstorm/&quot;&gt;PhpStorm&lt;/a&gt; -一个商业PHP IDE&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;web-applicationsweb应用&quot;&gt;Web Applications Web应用&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;基于Web的应用和工具&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://3v4l.org/&quot;&gt;3V4L&lt;/a&gt;一个在线的PHP shell&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://dbv.vizuina.com/&quot;&gt;DBV&lt;/a&gt; -一个数据库版本控制应用&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/CoderKungfu/php-queue&quot;&gt;PHP Queue&lt;/a&gt; -一个管理后端队列的应用&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://composer.borreli.com/&quot;&gt;Composer as a Service&lt;/a&gt; - 作为一个zip文件下载Composer包的工具&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/sj26/mailcatcher&quot;&gt;MailCatcher&lt;/a&gt; - 一个抓取和查看邮件的web工具&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;resources资源&quot;&gt;Resources 资源&lt;/h1&gt;

&lt;p&gt;各种提高你的PHP开发技能和知识的资源，比如书籍，网站，文章&lt;/p&gt;

&lt;h2 id=&quot;php网站&quot;&gt;PHP网站&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;PHP相关的有用网站&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.phptherightway.com/&quot;&gt;PHP The Right Way&lt;/a&gt; -一个PHP最佳实践的快速指引手册&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://phpbestpractices.org/&quot;&gt;PHP Best Practices&lt;/a&gt; - 一个PHP最佳实践指南&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://phpweekly.info/archive/&quot;&gt;PHP Weekly&lt;/a&gt; - 一个PHP新闻周刊&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://phpsecurity.readthedocs.org/en/latest/index.html&quot;&gt;PHP Security&lt;/a&gt; - 一个PHP安全指南&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.php-fig.org/&quot;&gt;PHP FIG&lt;/a&gt; - PHP框架交互组&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://php.ug/&quot;&gt;PHP UG&lt;/a&gt; -一个帮助用户定位最近的PHP用户组（UG)的网站&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://7php.com/&quot;&gt;Seven PHP&lt;/a&gt; -一个PHP社区成员采访的网站&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://nomadphp.com/&quot;&gt;Nomad PHP&lt;/a&gt; -一个在线PHP学习资源&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://phpmentoring.org/&quot;&gt;PHP Mentoring&lt;/a&gt; -点对点PHP导师组织&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;other-websites其他网站&quot;&gt;Other Websites 其他网站&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;web开发相关的有用网站&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.owasp.org/index.php/Main_Page&quot;&gt;The Open Web Application Security Project (OWASP)&lt;/a&gt; -一个开放软件安全社区&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://websec.io/&quot;&gt;WebSec IO&lt;/a&gt; - 一个web安全社区资源&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://webadvent.org/&quot;&gt;Web Advent&lt;/a&gt; -一个web开发人员日历&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://semver.org/&quot;&gt;Semantic Versioning&lt;/a&gt; -一个解析语义版本的网站&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.atlassian.com/git&quot;&gt;Atlassian Git Tutorials&lt;/a&gt; -一个Git教程系列&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://hginit.com/&quot;&gt;Hg Init&lt;/a&gt; -一个Mercurial教程系列&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://serversforhackers.com/&quot;&gt;Servers for Hackers&lt;/a&gt; - 一个关于服务器管理的新闻通讯&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;php-书籍&quot;&gt;PHP 书籍&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;PHP相关的非常好的书籍&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.scalingphpbook.com/&quot;&gt;Scaling PHP Applications&lt;/a&gt; - 一本Steve Corona关于扩展PHP应用程序的电子书&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://leanpub.com/grumpy-testing&quot;&gt;The Grumpy Programmer’s Guide to Building Testable PHP Applications&lt;/a&gt; -一本Chris Hartjes关于构建PHP应用程序测试的书&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://leanpub.com/grumpy-phpunit&quot;&gt;Grumpy PHPUnit&lt;/a&gt; -一本Chris Hartjes关于使用PHPUnit进行单元测试的书&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.brandonsavage.net/&quot;&gt;Mastering Object-Orientated PHP&lt;/a&gt; - 一本Brandon Savage关于PHP面向对象的书&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://leanpub.com/signalingphp&quot;&gt;Signaling PHP&lt;/a&gt; -一本Cal Evans关于在CLI脚本捕获PCNTL 信号的书&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://leanpub.com/securingphp-coreconcepts&quot;&gt;Securing PHP: Core Concepts&lt;/a&gt; -一本Chris Cornutt关于PHP常见安全条款和实践的书&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://leanpub.com/mlaphp&quot;&gt;Modernising Legacy Applications in PHP&lt;/a&gt; -一本Paul M.Jones关于遗留PHP应用进行现代化的书&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;其他书籍&quot;&gt;其他书籍&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;与一般计算和web开发相关的书&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://linuxcommand.org/tlcl.php&quot;&gt;The Linux Command Line&lt;/a&gt; -William Shotts关于Linux命令行的一本书&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://computationbook.com/&quot;&gt;Understanding Computation&lt;/a&gt; -Tom Stuart关于计算理论的一本书&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.amazon.ca/The-Tangled-Web-Securing-Applications/dp/1593273886&quot;&gt;The Tangled Web — Securing Web Applications&lt;/a&gt; - Michal Zalewski关于web应用安全的一本书&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.elasticsearch.org/guide/&quot;&gt;Elasticsearch: The Definitive Guide&lt;/a&gt; -Clinton Cormley和Zachary Tong编写的与Elasticsearch工作的一本指南&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://eloquentjavascript.net/&quot;&gt;Eloquent JavaScript&lt;/a&gt; -Marijin Haverbeke关于JavaScript编程的一本书&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://leanpub.com/vagrantcookbook&quot;&gt;Vagrant Cookbook&lt;/a&gt;-Erika Heidi关于创建 Vagrant环境的一本书&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://git-scm.com/book/en/v2&quot;&gt;Pro Git&lt;/a&gt; -Scott Chacon和Ben Straub关于Git的一本书&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;php视频&quot;&gt;PHP视频&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;PHP相关的非常不错的视频&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.infoq.com/presentations/php-history&quot;&gt;Taking PHP Seriously&lt;/a&gt; - 来自Facebook Keith Adams 讲述PHP优势&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://phptownhall.com/&quot;&gt;PHP Town Hall&lt;/a&gt; - 一个随意的Ben Edmunds和Phil Sturgeon的PHP播客&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.youtube.com/playlist?list=PLM-218uGSX3DQ3KsB5NJnuOqPqc5CW2kW&quot;&gt;Programming with Anthony&lt;/a&gt;  Anthony Ferrara的视频系列&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;php阅读&quot;&gt;PHP阅读&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;PHP相关的阅读资料&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://fabien.potencier.org/article/50/create-your-own-framework-on-top-of-the-symfony2-components-part-1&quot;&gt;Create Your Own PHP Framework&lt;/a&gt; - 一部Fabien Potencier的关于如何创建你自己的PHP框架的系列文章&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://blog.ircmaxell.com/2012/12/seven-ways-to-screw-up-bcrypt.html&quot;&gt;Seven Ways to Screw Up BCrypt&lt;/a&gt; - 一篇关于纠正BCrypt实现的文章&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://blog.ircmaxell.com/2013/02/preventing-csrf-attacks.html&quot;&gt;Preventing CSRF Attacks&lt;/a&gt; -一篇组织CSRF攻击的文章&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://blog.ircmaxell.com/2013/08/dont-worry-about-breach.html&quot;&gt;Don’t Worry About BREACH&lt;/a&gt; - 一篇关于BREACH攻击和CSRF令牌的文章&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://fabien.potencier.org/article/17/on-php-5-3-lambda-functions-and-closures&quot;&gt;On PHP 5.3, Lamda Functions and Closures&lt;/a&gt; -一篇关于lambda函数和闭包的文章&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://seancoates.com/blogs/use-env&quot;&gt;Use Env&lt;/a&gt; - 一篇关于使用unix环境帮助的文章&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://daylerees.com/composer-primer&quot;&gt;Composer Primer&lt;/a&gt; - Composer初级&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://igor.io/2013/01/07/composer-versioning.html&quot;&gt;Composer Versioning&lt;/a&gt; -一篇关于Composer版本的文章&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://igor.io/2013/02/07/composer-stability-flags.html&quot;&gt;Composer Stability Flags&lt;/a&gt; -一篇关于Composer稳定性标志的文章&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://blog.astrumfutura.com/2012/04/php-innocent-villagefolk-or-a-pillagin-pirate/&quot;&gt;Innocent Villagefolk or a Pillagin’ Pirate?&lt;/a&gt; -一篇关于PHP从其他语言获取想法的文章&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://blog.astrumfutura.com/2013/03/predicting-random-numbers-in-php-its-easier-than-you-think/&quot;&gt;Predicting Random Numbers in PHP&lt;/a&gt; -一篇关于生成随机数的文章&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://blog.astrumfutura.com/2013/04/20-point-list-for-preventing-cross-site-scripting-in-php/&quot;&gt;A 20 Point List for Preventing XSS in PHP&lt;/a&gt; -一篇关于组织XSS的文章&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://blog.ircmaxell.com/2012/04/php-sucks-but-i-like-it.html&quot;&gt;PHP Sucks! But I Like It!&lt;/a&gt; -一篇关于PHP利弊的文章&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://fabien.potencier.org/article/64/php-is-much-better-than-you-think&quot;&gt;PHP Is Much Better Than You Think&lt;/a&gt; -一篇关于PHP语言和生态圈的文章&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;php-internals-readingphp内核阅读&quot;&gt;PHP Internals Reading PHP内核阅读&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;阅读PHP内核或性能相关的资料&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://wiki.php.net/rfc&quot;&gt;PHP RFCs&lt;/a&gt; - PHP RFCs主页（请求注解）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://www.phpinternalsbook.com/&quot;&gt;PHP Internals Book&lt;/a&gt; - 一本由三名核心开发编写的关于PHP内核的在线书&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://fabien.potencier.org/article/8/print-vs-echo-which-one-is-faster&quot;&gt;Print vs Echo, Which One is Faster?&lt;/a&gt; -一篇关于打印和echo性能的文章&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://fabien.potencier.org/article/48/the-php-ternary-operator-fast-or-not&quot;&gt;The PHP Ternary Operator. Fast or Not?&lt;/a&gt; -一篇关于三元操作性能的文章&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://nikic.github.com/2012/01/09/Disproving-the-Single-Quotes-Performance-Myth.html&quot;&gt;Disproving the Single Quotes Myth&lt;/a&gt; -一篇关于单，双引号字符串性能的文章&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://blog.golemon.com/2007/01/youre-being-lied-to.html&quot;&gt;You’re Being Lied To&lt;/a&gt; - 一篇关于内核ZVALs的文章&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://blog.golemon.com/2006/06/how-long-is-piece-of-string.html&quot;&gt;How Long is a Piece of String&lt;/a&gt; -一篇关于字符串原理的文章&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://blog.golemon.com/2008/01/understanding-opcodes.html&quot;&gt;Understanding OpCodes&lt;/a&gt; -一篇关于伪代码的文章&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://stackoverflow.com/questions/10057671/how-foreach-actually-works/14854568#14854568&quot;&gt;How Foreach Works&lt;/a&gt; -StackOverflow 关于foreach回答的详情&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://nikic.github.com/2011/11/11/PHP-Internals-When-does-foreach-copy.html&quot;&gt;When Does Foreach Copy?&lt;/a&gt; -一篇关于foreach原理的文章&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://nikic.github.com/2011/12/12/How-big-are-PHP-arrays-really-Hint-BIG.html&quot;&gt;How Big Are PHP Arrays (And Values) Really?&lt;/a&gt; - 一篇关于数组原理的文章&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://gist.github.com/nikic/5015323&quot;&gt;Why Objects (Usually) Use Less Memory Than Arrays&lt;/a&gt; -一篇关于对象和数组原理的文章&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://gist.github.com/nikic/6699370&quot;&gt;PHP Evaluation Order&lt;/a&gt; -一篇关于PHP评估顺序的文章&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;开发人员的PHP源代码： &lt;a href=&quot;http://blog.ircmaxell.com/2012/03/phps-source-code-for-php-developers.html&quot;&gt;1&lt;/a&gt; &lt;a href=&quot;http://nikic.github.com/2012/03/16/Understanding-PHPs-internal-function-definitions.html&quot;&gt;2&lt;/a&gt; &lt;a href=&quot;http://blog.ircmaxell.com/2012/03/phps-source-code-for-php-developers_21.html&quot;&gt;3&lt;/a&gt; &lt;a href=&quot;http://nikic.github.com/2012/03/28/Understanding-PHPs-internal-array-implementation.html&quot;&gt;4&lt;/a&gt; -关于PHP源代码的系列&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;垃圾收集： &lt;a href=&quot;http://www.php.net/manual/en/features.gc.refcounting-basics.php&quot;&gt;1&lt;/a&gt; &lt;a href=&quot;http://www.php.net/manual/en/features.gc.collecting-cycles.php&quot;&gt;2&lt;/a&gt; &lt;a href=&quot;http://www.php.net/manual/en/features.gc.performance-considerations.php&quot;&gt;3&lt;/a&gt; 关于PHP垃圾收集原理的系列&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 05 Jan 2015 14:19:35 +0800</pubDate>
        <link>http://localhost:4000/blog/2015/01/05/php-e8-b5-84-e6-ba-90-e5-a4-a7-e5-85-a8-ef-bc-88-e8-bd-ac-ef-bc-89/</link>
        <guid isPermaLink="true">http://localhost:4000/blog/2015/01/05/php-e8-b5-84-e6-ba-90-e5-a4-a7-e5-85-a8-ef-bc-88-e8-bd-ac-ef-bc-89/</guid>
        
        
        <category>技术文章</category>
        
      </item>
    
  </channel>
</rss>
